const SPREADSHEET_ID = '1rhP1UCiMLi8yNVvcd56SsZIJAm09Yxu6WpjxuHKYKb0';
const MASTER_SPREADSHEET_ID = '1SiB4k-T7HoT9cNv-Q8KPIS3AnA6C_8HAX0hFyR3ZWOc';
const MASTER_SHEET_NAME = 'menu';

function doPost(e) {
  let result;
  try {
    const data = JSON.parse(e.postData.contents);
    const action = data.action;

    switch (action) {
      case 'sendOTP': result = handleSendOTP(data); break;
      case 'verifyOTP': result = handleVerifyOTP(data); break;
      case 'register': result = handleRegister(data); break;
      case 'login': result = handleLogin(data); break;
      case 'getUsers': result = getUsers(data); break;
      case 'createUser': result = handleCreateUser(data); break;
      case 'updateRole': result = handleUpdateRole(data); break;
      case 'updateOwner': result = handleUpdateOwner(data); break;
      case 'deleteUser': result = handleDeleteUser(data); break;
      case 'resetPassword': result = handleResetPassword(data); break;
      case 'get_phan_quyen': result = getPhanQuyen(); break;
      case 'save_phan_quyen': result = savePhanQuyen(data); break;
      case 'getRoles': result = getRoles(); break;
      case 'getUserConfig': result = { success: true, features: getUserPackage(data.email).features }; break;
      case 'get_permissions': result = { success: true, permissions: getPermissions(data.roleId, data.adminEmail) }; break;
      case 'setup': result = initSystem(); break;
      default: 
        result = { success: false, message: 'H√†nh ƒë·ªông kh√¥ng h·ª£p l·ªá' };
    }
  } catch (error) {
    result = { success: false, message: 'L·ªói h·ªá th·ªëng: ' + error.toString() };
  }
  return ContentService.createTextOutput(JSON.stringify(result)).setMimeType(ContentService.MimeType.JSON);
}

// --- CONFIG & UTILS ---
function getSheet(name) { return SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(name); }
function hashPassword(p) { return Utilities.computeDigest(Utilities.DigestAlgorithm.SHA_256, p).map(b => ('0' + (b & 0xFF).toString(16)).slice(-2)).join(''); }

const XOR_SECRET = 'dunvex_secure_key_2025_custom';
const AES_KEY = Utilities.newBlob('dunvex_secure_16').getBytes();

function encryptData(text) {
  if (!text) return "";
  const inputBytes = Utilities.newBlob(text.toString()).getBytes();
  const keyBytes = Utilities.newBlob(XOR_SECRET).getBytes();
  const outputBytes = [];
  for (let i = 0; i < inputBytes.length; i++) {
    outputBytes.push(inputBytes[i] ^ keyBytes[i % keyBytes.length]);
  }
  return Utilities.base64Encode(outputBytes);
}

function decryptData(text) {
  if (!text || text === 'n/a') return "";
  const cleanText = text.toString().trim();
  try {
    const bytes = Utilities.base64Decode(cleanText);
    const keyBytes = Utilities.newBlob(XOR_SECRET).getBytes();
    let result = "";
    for (let i = 0; i < bytes.length; i++) {
        result += String.fromCharCode(bytes[i] ^ keyBytes[i % keyBytes.length]);
    }
    return result;
  } catch (e) { return text; }
}

// --- CORE FUNCTIONS ---
function findUserInSheet(sName, email, hashedPass, isUseSheet = false) {
  const sheet = getSheet(sName);
  if (!sheet || sheet.getLastRow() <= 1) return null;
  const rows = sheet.getDataRange().getValues();
  const searchEmail = email.toLowerCase().trim();

    for (let i = 1; i < rows.length; i++) {
        const rowEmail = decryptData(rows[i][1]).toLowerCase();
        const rowPass = (rows[i][2] || "").toString().trim();
        if (rowEmail === searchEmail && (hashedPass === null || rowPass === hashedPass)) {
            const userData = {
                id: rows[i][0],
                email: rowEmail,
                fullName: rows[i][3],
                roleId: rows[i][4],
                status: isUseSheet ? rows[i][6] : rows[i][5]
            };
            if (isUseSheet) {
                userData.owner = decryptData(rows[i][5]);
            } else {
                userData.owner = rowEmail; // Admin owns themselves/their org
            }
            return userData;
        }
    }
  return null;
}

function handleLogin(d) {
  const email = (d.email || "").toLowerCase().trim();
  const hashedPass = hashPassword(d.password || "");
  const user = findUserInSheet('admin', email, hashedPass) || findUserInSheet('use', email, hashedPass, true);
  
  if (!user) {
    logAction('ƒêƒÉng nh·∫≠p', email, 'Th·∫•t b·∫°i', 'Guest');
    return { success: false, message: 'Sai th√¥ng tin ƒëƒÉng nh·∫≠p' };
  }

  // KI·ªÇM TRA TR·∫†NG TH√ÅI T√ÄI KHO·∫¢N (Master Lock)
  if (user.status === 'T·∫°m kh√≥a') {
    logAction('ƒêƒÉng nh·∫≠p', email, 'B·ªã ch·∫∑n (T·∫°m kh√≥a)', email);
    return { 
      success: false, 
      message: 'T√†i kho·∫£n c·ªßa b·∫°n hi·ªán ƒëang b·ªã [T·∫°m kh√≥a]. Vui l√≤ng li√™n h·ªá Email: dunvex.green@gmail.com ƒë·ªÉ x·ª≠ l√Ω.' 
    };
  }

  let adminEmail = email; 
  if (user.id.startsWith('US')) {
    const rows = getSheet('use').getDataRange().getValues();
    const row = rows.find(r => decryptData(r[1]).toLowerCase() === email);
    if (row) adminEmail = decryptData(row[5]);
  }
  
  // X√°c ƒë·ªãnh g√≥i c∆∞·ªõc & h·∫°n ch·∫ø (D·ª±a tr√™n Admin s·ªü h·ªØu)
  const pkgInfo = getUserPackage(adminEmail);
  user.package = pkgInfo.package;
  user.expiry = pkgInfo.expiry;
  user.salesRestrict = pkgInfo.salesRestrict; // NEW: Tr·∫°ng th√°i h·∫°n ch·∫ø b√°o c√°o
  user.features = pkgInfo.features; // NEW: Global feature locks
  user.adminEmail = adminEmail; // Email Admin g·ªëc (Ch·ªß c√¥ng ty)

  // T·ª∞ ƒê·ªòNG T√åM T·∫§T C·∫¢ ADMIN TRONG C√îNG TY (Org Admins)
  const allUseSheet = getSheet('use');
  const allUseData = allUseSheet.getDataRange().getValues();
  const orgAdmins = [adminEmail]; // B·∫Øt ƒë·∫ßu b·∫±ng Admin g·ªëc
  
  for (let i = 1; i < allUseData.length; i++) {
    const uRole = allUseData[i][4];
    const uOwner = (decryptData(allUseData[i][5]) || "").toLowerCase().trim();
    const uEmail = (decryptData(allUseData[i][1]) || "").toLowerCase().trim();
    
    // N·∫øu c√πng ch·ªß (Owner) v√† l√† Admin (R001) th√¨ th√™m v√†o danh s√°ch qu·∫£n l√Ω chung
    if (uOwner === adminEmail && uRole === 'R001' && uEmail !== adminEmail) {
      orgAdmins.push(uEmail);
    }
  }
  user.orgAdmins = [...new Set(orgAdmins)].join(', '); // G·ªôp th√†nh chu·ªói c√°ch nhau b·ªüi d·∫•u ph·∫©y

  logAction('ƒêƒÉng nh·∫≠p', email, 'Th√†nh c√¥ng', email);
  return { success: true, user: user, permissions: getPermissions(user.roleId, adminEmail) };
}

function getUserPackage(email) {
  try {
    const ss = SpreadsheetApp.openById(MASTER_SPREADSHEET_ID);
    const sheet = ss.getSheetByName(MASTER_SHEET_NAME);
    if (!sheet) return { package: 'Free', expiry: '' };
    const rows = sheet.getDataRange().getValues();
    const config = rows.find(r => r[0].toString().toLowerCase() === email.toLowerCase());
    return config ? { 
      package: config[1], 
      expiry: config[3],
      salesRestrict: config[10] || 'OFF',
      features: JSON.parse(config[4] || '{}')
    } : { package: 'Free', expiry: '', salesRestrict: 'OFF', features: {} };
  } catch (e) { return { package: 'Free', expiry: '', salesRestrict: 'OFF', features: {} }; }
}

// --- OTP & REGISTRATION ---
function handleSendOTP(data) {
  const email = (data.email || "").toString().trim().toLowerCase();
  const otp = Math.floor(100000 + Math.random() * 900000).toString();
  const expire = new Date(new Date().getTime() + 5 * 60000); // 5 mins
  const sheet = getSheet('otps');
  
  // Clean old OTPs
  if(sheet.getLastRow() > 0) {
    const rows = sheet.getDataRange().getValues();
    for (let i = rows.length - 1; i >= 1; i--) {
        if (rows[i][0] && decryptData(rows[i][0]) === email) sheet.deleteRow(i + 1);
    }
  }
  
  // Save new OTP
  const encEmail = encryptData(email);
  sheet.appendRow([encEmail, otp, expire]);
  
  try {
    MailApp.sendEmail({
      to: email,
      subject: "M√£ x√°c th·ª±c Dunvex Account: " + otp,
      htmlBody: `
        <div style="font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; max-width: 500px; margin: 20px auto; border: 1px solid #6366f1; border-radius: 16px; padding: 40px 20px; box-sizing: border-box;">
          <h2 style="color: #6366f1; text-align: center; font-size: 24px; margin-bottom: 20px; font-weight: 800;">X√°c th·ª±c OTP</h2>
          <p style="text-align: center; color: #475569; font-size: 15px; margin-bottom: 30px;">
            Ch√†o b·∫°n, ƒë√¢y l√† m√£ x√°c th·ª±c ƒë·ªÉ b·∫°n th·ª±c hi·ªán thay ƒë·ªëi tr√™n h·ªá th·ªëng Dunvex:
          </p>
          <div style="background: #f0f7ff; border: 1px solid #6366f1; padding: 25px; text-align: center; border-radius: 12px; margin: 20px 0;">
            <span style="font-size: 48px; font-weight: 900; letter-spacing: 12px; color: #1e1b4b; display: block;">${otp}</span>
          </div>
          <p style="text-align: center; font-size: 12px; color: #94a3b8; margin-top: 30px;">
            M√£ c√≥ hi·ªáu l·ª±c trong 5 ph√∫t. Vui l√≤ng b·∫£o m·∫≠t m√£ n√†y.
          </p>
        </div>
      `
    });
    return { success: true, message: 'ƒê√£ g·ª≠i m√£ x√°c th·ª±c!' };
  } catch (e) { return { success: false, message: e.toString() }; }
}

function handleVerifyOTP(data) {
  const success = verifyOTP(data.email, data.otp);
  return { success: success, message: success ? "X√°c th·ª±c th√†nh c√¥ng" : "M√£ OTP kh√¥ng ƒë√∫ng ho·∫∑c h·∫øt h·∫°n" };
}

function verifyOTP(email, otp) {
  const sheet = getSheet('otps');
  if(sheet.getLastRow() <= 1) return false;
  const rows = sheet.getDataRange().getValues();
  const now = new Date().getTime();
  const lowerEmail = email.toLowerCase();
  
  for (let i = 1; i < rows.length; i++) {
    const rowEmail = decryptData(rows[i][0]);
    if (rowEmail === lowerEmail && rows[i][1].toString() === otp.toString()) {
      if (now < new Date(rows[i][2]).getTime()) { 
        sheet.deleteRow(i + 1); 
        return true; 
      }
    }
  }
  return false;
}

function handleRegister(data) {
  const email = (data.email || "").toLowerCase().trim();
  if (!verifyOTP(email, data.otp)) return { success: false, message: 'OTP sai ho·∫∑c h·∫øt h·∫°n' };
  
  const roleId = data.roleId || 'R005';
  const prefix = (roleId === 'R001' ? 'AD' : 'US');
  const sheetName = (roleId === 'R001' ? 'admin' : 'use');
  const id = generateNextId(sheetName, prefix);
  const encEmail = encryptData(email);
  
  const sheet = getSheet(sheetName);
  if (roleId === 'R001') {
    sheet.appendRow([id, encEmail, hashPassword(data.password), data.fullName, 'R001', 'Ho·∫°t ƒë·ªông', new Date()]);
  } else {
    sheet.appendRow([id, encEmail, hashPassword(data.password), data.fullName, 'R005', encryptData('n/a'), 'Ho·∫°t ƒë·ªông', new Date()]);
  }
  return { success: true };
}

function handleResetPassword(d) {
  const email = (d.email || "").toString().trim().toLowerCase();
  const newPass = (d.newPassword || "").toString().trim();
  
  if (!verifyOTP(email, d.otp)) return { success: false, message: 'OTP sai ho·∫∑c h·∫øt h·∫°n' };
  
  for (let name of ['admin', 'use']) {
    const sheet = getSheet(name);
    if (!sheet || sheet.getLastRow() <= 1) continue;
    const rows = sheet.getDataRange().getValues();
    for (let i = 1; i < rows.length; i++) {
      const rowEmail = decryptData(rows[i][1]).toLowerCase();
      if (rowEmail === email) {
        sheet.getRange(i + 1, 3).setValue(hashPassword(newPass));
        return { success: true };
      }
    }
  }
  return { success: false, message: 'Kh√¥ng t√¨m th·∫•y t√†i kho·∫£n v·ªõi email n√†y' };
}

function getUsers(d) {
  const sheet = getSheet('use');
  if (sheet.getLastRow() <= 1) return { success: true, users: [] };
  const rows = sheet.getDataRange().getValues();
  
  // Chu·∫©n h√≥a Email ng∆∞·ªùi y√™u c·∫ßu
  const reqEmail = (d.adminEmail || "").toLowerCase().trim();
  const reqUser = reqEmail.split('@')[0];

  // 1. T√¨m "S·∫øp T·ªïng" (ID g·ªëc c·ªßa t·ªï ch·ª©c)
  let bossEmail = reqEmail;
  for (let i = 1; i < rows.length; i++) {
    const plainEmail = (decryptData(rows[i][1]) || "").toLowerCase().trim();
    if (plainEmail === reqEmail || plainEmail === reqUser) {
      const parent = (decryptData(rows[i][5]) || "").toLowerCase().trim();
      if (parent && parent !== 'n/a') {
        bossEmail = parent;
        break;
      }
    }
  }
  const bossUser = bossEmail.split('@')[0];

  // 2. T√¨m t·∫•t c·∫£ Admin c√πng nh√≥m ƒë·ªÉ gom v√†o "Nh√≥m Admin Qu·∫£n L√Ω"
  const orgAdmins = [bossEmail];
  for (let i = 1; i < rows.length; i++) {
    const uRole = (rows[i][4] || "").toString().trim().toUpperCase();
    const uEmail = (decryptData(rows[i][1]) || "").toLowerCase().trim();
    const uOwner = (decryptData(rows[i][5]) || "").toLowerCase().trim();
    
    const isThisOrg = (uOwner === bossEmail || uOwner === bossUser || uEmail === bossEmail || uEmail === bossUser);
    if ((uRole === 'R001' || uRole === 'ADMIN') && isThisOrg) {
      if (uEmail && orgAdmins.indexOf(uEmail) === -1) orgAdmins.push(uEmail);
    }
  }
  const groupText = [...new Set(orgAdmins)].map(em => em.split('@')[0].trim()).filter(n => n && n !== 'n/a').join(', ');

  // 3. L·ªçc danh s√°ch tr·∫£ v·ªÅ (Hi·ªán t·∫•t c·∫£ tr·ª´ b·∫£n th√¢n)
  const users = [];
  for (let i = 1; i < rows.length; i++) {
    const uEmail = (decryptData(rows[i][1]) || "").toLowerCase().trim();
    const uOwner = (decryptData(rows[i][5]) || "").toLowerCase().trim();
    
    if (!uEmail || uEmail === 'n/a') continue;

    const uUser = uEmail.split('@')[0];
    const uOwnerUser = uOwner.split('@')[0];

    // ƒêi·ªÅu ki·ªán: B·∫°n l√† S·∫øp c·ªßa h·ªç, ho·∫∑c h·ªç c√πng S·∫øp v·ªõi b·∫°n
    const isSameOrg = (
      uOwner === bossEmail || uOwnerUser === bossUser || 
      uEmail === bossEmail || uUser === bossUser
    );
    const isMe = (uEmail === reqEmail || uUser === reqUser);

    if (isSameOrg && !isMe) {
      users.push({
        id: rows[i][0],
        email: uEmail,
        fullName: rows[i][3],
        roleId: rows[i][4],
        owner: groupText,
        status: rows[i][6]
      });
    }
  }
  return { success: true, users: users };
}

function handleCreateUser(d) {
  const email = d.email.toLowerCase().trim();
  const adminEmail = (d.adminEmail || "").toLowerCase().trim();
  
  // KI·ªÇM TRA GI·ªöI H·∫†N NH√ÇN S·ª∞
  const pkgInfo = getUserPackage(adminEmail);
  const limit = pkgInfo.package === 'Premium' ? 50 : 5;
  
  const sheet = getSheet('use');
  const rows = sheet.getDataRange().getValues();
  let currentCount = 0;

  for (let i = 1; i < rows.length; i++) {
    const assigned = (decryptData(rows[i][5]) || "").toLowerCase().trim();
    if (assigned === adminEmail) currentCount++;

    if (decryptData(rows[i][1]).toLowerCase() === email) {
      if (!assigned || assigned === 'n/a') {
        if (currentCount >= limit) return { success: false, message: `B·∫°n ƒë√£ ƒë·∫°t gi·ªõi h·∫°n ${limit} nh√¢n vi√™n. Vui l√≤ng n√¢ng c·∫•p Premium ƒë·ªÉ th√™m t·ªëi ƒëa 50 mail.` };
        sheet.getRange(i + 1, 6).setValue(encryptData(adminEmail));
        return { success: true, message: 'ƒê√£ k·∫øt n·ªëi t√†i kho·∫£n c≈© v√†o danh s√°ch c·ªßa b·∫°n!' };
      }
      return { success: false, message: 'Email ƒë√£ thu·ªôc Admin kh√°c' };
    }
  }

  if (currentCount >= limit) return { success: false, message: `B·∫°n ƒë√£ ƒë·∫°t gi·ªõi h·∫°n ${limit} nh√¢n vi√™n. Vui l√≤ng n√¢ng c·∫•p Premium ƒë·ªÉ th√™m t·ªëi ƒëa 50 mail.` };

  const id = generateNextId('use', 'US');
  sheet.appendRow([id, encryptData(email), hashPassword(d.password || '123456'), d.fullName, d.roleId, encryptData(adminEmail), 'Ho·∫°t ƒë·ªông', new Date()]);
  return { success: true };
}

function handleUpdateRole(d) {
  const sheet = getSheet('use');
  const rows = sheet.getDataRange().getValues();
  const email = d.userEmail.toLowerCase().trim();
  for (let i = 1; i < rows.length; i++) {
    if (decryptData(rows[i][1]).toLowerCase() === email) {
      sheet.getRange(i+1, 5).setValue(d.newRoleId);
      sheet.getRange(i+1, 2).setValue(encryptData(email)); // Force re-encrypt XOR
      return { success: true };
    }
  }
  return { success: false };
}

function handleUpdateOwner(d) {
  const sheet = getSheet('use');
  const rows = sheet.getDataRange().getValues();
  const email = d.userEmail.toLowerCase().trim();
  const newOwner = d.newOwner.toLowerCase().trim();
  for (let i = 1; i < rows.length; i++) {
    if (decryptData(rows[i][1]).toLowerCase() === email) {
      sheet.getRange(i+1, 6).setValue(encryptData(newOwner)); // Column F: Owner
      sheet.getRange(i+1, 2).setValue(encryptData(email)); // Force re-encrypt XOR
      return { success: true };
    }
  }
  return { success: false, message: "Kh√¥ng t√¨m th·∫•y t√†i kho·∫£n" };
}

function handleDeleteUser(d) {
  try {
    const email = (d.userEmail || "").toLowerCase().trim();
    const adminEmail = (d.adminEmail || "").toLowerCase().trim();
    
    // 1. T√¨m trong sheet 'use' (Nh√¢n vi√™n)
    const useSheet = getSheet('use');
    if (!useSheet) return { success: false, message: 'L·ªói h·ªá th·ªëng: Kh√¥ng t√¨m th·∫•y b·∫£ng d·ªØ li·ªáu nh√¢n vi√™n' };
    
    const useRows = useSheet.getDataRange().getValues();
    for (let i = 1; i < useRows.length; i++) {
        const rowEmail = decryptData(useRows[i][1]).toLowerCase();
        if (rowEmail === email) {
            const assigned = (decryptData(useRows[i][5]) || "").toLowerCase().trim();
            
            // Ki·ªÉm tra quy·ªÅn Root
            const adminSheet = getSheet('admin');
            const adminRows = adminSheet ? adminSheet.getDataRange().getValues() : [];
            const isRoot = adminRows.some((r, idx) => idx > 0 && decryptData(r[1]).toLowerCase() === adminEmail);
            
            if (isRoot || assigned === adminEmail) {
                useSheet.deleteRow(i + 1);
                logAction('X√≥a nh√¢n vi√™n', email, 'Th√†nh c√¥ng', adminEmail);
                return { success: true, message: 'ƒê√£ x√≥a t√†i kho·∫£n nh√¢n vi√™n th√†nh c√¥ng!' };
            }
            return { success: false, message: 'B·∫°n kh√¥ng c√≥ quy·ªÅn x√≥a t√†i kho·∫£n n√†y' };
        }
    }
    
    return { success: false, message: 'Kh√¥ng t√¨m th·∫•y t√†i kho·∫£n nh√¢n vi√™n c·∫ßn x√≥a' };
  } catch (e) {
    return { success: false, message: 'L·ªói x·ª≠ l√Ω x√≥a: ' + e.toString() };
  }
}

function getPermissions(roleId, adminEmail = "ALL") {
  const sheet = getSheet('phan_quyen');
  if (!sheet || sheet.getLastRow() <= 1) return null;
  const rows = sheet.getDataRange().getValues();
  const targetAdmin = adminEmail.toLowerCase().trim();
  let specific = null, general = null;

  for (let i = 1; i < rows.length; i++) {
    if (rows[i][0] == roleId) {
      const p = { 
        checkinSales:!!rows[i][3], quanLySanPham:!!rows[i][4], danhSachDonHang:!!rows[i][5], 
        quanLyNhanVien:!!rows[i][6], xemBangGia:!!rows[i][7], quanLyKho:!!rows[i][8],
        notifyStaff:!!rows[i][9], notifyAdmin:!!rows[i][10], checkinSummary:!!rows[i][11],
        quanLyCongNo:!!rows[i][12]
      };
      let rowAdmin = decryptData(rows[i][2]).toLowerCase().trim();
      if (!rowAdmin || rowAdmin === 'n/a' || rowAdmin === 'empty') rowAdmin = 'all';
      
      if (rowAdmin === targetAdmin) specific = p;
      if (rowAdmin === 'all') general = p;
    }
  }
  return specific || general;
}

function getPhanQuyen() {
  const sheet = getSheet('phan_quyen');
  if (!sheet || sheet.getLastRow() <= 1) return { success: true, data: [] };
  const rows = sheet.getDataRange().getValues();
  return { 
    success: true, 
    data: rows.slice(1).map(r => {
      let em = decryptData(r[2]).toLowerCase().trim();
      if (!em || em === 'n/a' || em === 'empty') em = 'all';
      return {
        id_vai_tro: r[0], ten_vai_tro: r[1], email_quan_ly: em,
        checkin_sales: !!r[3], quan_ly_san_pham: !!r[4], danh_sach_don_hang: !!r[5],
        quan_ly_nhan_vien: !!r[6], xem_bang_gia: !!r[7], quan_ly_kho: !!r[8],
        notify_staff: !!r[9], notify_admin: !!r[10], checkin_summary: !!r[11],
        quan_ly_cong_no: !!r[12]
      };
    })
  };
}

function savePhanQuyen(d) {
  const sheet = getSheet('phan_quyen');
  const rows = sheet.getDataRange().getValues();
  const adminPlain = (d.email_quan_ly || "all").toLowerCase().trim();
  
  // KI·ªÇM TRA KH√ìA MASTER T·ª™ SUPER ADMIN
  const pkgInfo = getUserPackage(adminPlain === 'all' ? 'dunvex.green@gmail.com' : adminPlain);
  const f = pkgInfo.features || {};

  const adminEnc = encryptData(adminPlain);
  for (let i = 1; i < rows.length; i++) {
    let rowEm = decryptData(rows[i][2]).toLowerCase().trim();
    if (!rowEm || rowEm === 'n/a') rowEm = 'all';

    if (rows[i][0] == d.id_vai_tro && rowEm === adminPlain) {
      sheet.getRange(i+1, 4, 1, 10).setValues([[d.checkin_sales, d.quan_ly_san_pham, d.danh_sach_don_hang, d.quan_ly_nhan_vien, d.xem_bang_gia, d.quan_ly_kho, d.notify_staff, d.notify_admin, d.checkin_summary, d.quan_ly_cong_no]]);
      return { success: true };
    }
  }
  sheet.appendRow([d.id_vai_tro, d.ten_vai_tro, adminEnc, d.checkin_sales, d.quan_ly_san_pham, d.danh_sach_don_hang, d.quan_ly_nhan_vien, d.xem_bang_gia, d.quan_ly_kho, d.notify_staff, d.notify_admin, d.checkin_summary, d.quan_ly_cong_no]);
  return { success: true };
}

function getRoles() {
  const rows = getSheet('roles_lookup').getDataRange().getValues();
  return { success: true, roles: rows.filter((r, i) => i > 0 && r[0]).map(r => ({ id: r[0], name: r[1] })) };
}

function generateNextId(sName, prefix) {
  const sheet = getSheet(sName);
  const lastRow = sheet.getLastRow();
  if (lastRow <= 1) return prefix + '-001';
  const ids = sheet.getRange("A2:A" + lastRow).getValues().flat();
  const max = ids.reduce((m, id) => {
    const n = parseInt(id.toString().split('-').pop());
    return isNaN(n) ? m : Math.max(m, n);
  }, 0);
  return prefix + '-' + (max + 1).toString().padStart(3, '0');
}

function logAction(action, target, result, performer) {
  const sheet = getSheet('logs');
  if (!sheet) return;
  const now = new Date();
  const id = "L" + Utilities.formatDate(now, "GMT+7", "yyyyMMddHHmmss");
  sheet.appendRow([id, Utilities.formatDate(now, "GMT+7", "dd/MM/yyyy HH:mm:ss"), action, encryptData(target), result, encryptData(performer), "System"]);
}

function initSystem() {
  migrateAuthEmailsToEncrypted();
  return { success: true, message: 'ƒê√£ n√¢ng c·∫•p m√£ h√≥a XOR th√†nh c√¥ng!' };
}

function migrateAuthEmailsToEncrypted() {
  const configs = [
    { sheet: 'admin', cols: [1] },
    { sheet: 'use', cols: [1, 5] },
    { sheet: 'phan_quyen', cols: [2] },
    { sheet: 'logs', cols: [3, 5] }
  ];
  configs.forEach(c => {
    const s = getSheet(c.sheet); if (!s || s.getLastRow() < 2) return;
    const data = s.getDataRange().getValues();
    for (let i = 1; i < data.length; i++) {
      c.cols.forEach(col => {
        const val = (data[i][col] || "").toString();
        if (val.includes('@') && val.length < 50) s.getRange(i+1, col+1).setValue(encryptData(val.toLowerCase()));
      });
    }
  });
}

/**
 * H√ÄM C·∫¨P NH·∫¨T C·∫§U TR√öC PH√ÇN QUY·ªÄN (Th√™m c·ªôt th√¥ng b√°o mail)
 */
function migrate_UpdatePermissionHeaders() {
  const sheet = getSheet('phan_quyen');
  if (!sheet) return "‚ùå Kh√¥ng t√¨m th·∫•y sheet phan_quyen";
  
  const headers = [
    'Vai Tr√≤', 'T√™n Vai Tr√≤', 'Qu·∫£n L√Ω B·ªüi', 
    'CRM & Sales', 'Qu·∫£n L√Ω SP', 'Danh S√°ch ƒê∆°n', 
    'Qu·∫£n L√Ω NV', 'Xem B·∫£ng Gi√°', 'Qu·∫£n L√Ω Kho',
    'üì© Mail Nh√¢n vi√™n', 'üì© Mail Admin', 'üìç T·ªïng h·ª£p Check-in', 'üìä Qu·∫£n l√Ω C√¥ng n·ª£'
  ];
  
  sheet.getRange(1, 1, 1, headers.length).setValues([headers]);
  sheet.getRange(1, 1, 1, headers.length)
       .setBackground('#6366f1')
       .setFontColor('#ffffff')
       .setFontWeight('bold');
       
  SpreadsheetApp.flush();
  return "‚úÖ ƒê√£ c·∫≠p nh·∫≠t xong ti√™u ƒë·ªÅ cho sheet phan_quyen!";
}
