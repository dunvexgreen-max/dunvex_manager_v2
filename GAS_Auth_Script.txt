/**
 * GOOGLE APPS SCRIPT - OTP SYSTEM (FULLY AUTHENTICATED)
 * Spreadsheet ID: 1rhP1UCiMLi8yNVvcd56SsZIJAm09Yxu6WpjxuHKYKb0
 */

const SPREADSHEET_ID = '1rhP1UCiMLi8yNVvcd56SsZIJAm09Yxu6WpjxuHKYKb0';

function doPost(e) {
  let result;
  try {
    const data = JSON.parse(e.postData.contents);
    const action = data.action;

    switch (action) {
      case 'send_otp':
      case 'sendOTP':
        result = handleSendOTP(data); 
        break;
      case 'verify_otp':
      case 'verifyOTP':
        result = handleVerifyOTP(data); 
        break;
      case 'register': 
        result = handleRegister(data); 
        break;
      case 'login': 
        result = handleLogin(data); 
        break;
      case 'is_email_exists': 
        result = { success: isEmailExists(data.email) }; 
        break;
      case 'get_users': 
        result = getUsers(data); 
        break;
      case 'create_user': 
        result = handleCreateUser(data); 
        break;
      case 'updateRole':
      case 'update_role':
        result = handleUpdateRole(data);
        break;
      case 'reset_password':
      case 'resetPassword':
        result = handleResetPassword(data); 
        break;
      case 'get_phan_quyen': 
        result = getPhanQuyen(); 
        break;
      case 'save_phan_quyen': 
        result = savePhanQuyen(data); 
        break;
      case 'migrate_emails': 
        result = { success: true, message: migrateAuthEmailsToEncrypted() }; 
        break;
      case 'getRoles': 
        result = getRoles(); 
        break;
      case 'getUsers':
        result = getUsers(data);
        break;
      case 'createUser':
        result = handleCreateUser(data);
        break;
      case 'setup':
        result = initSystem();
        break;
      default: 
        result = { success: false, message: 'Hành động [' + action + '] không hợp lệ tại Auth Script' };
    }
  } catch (error) {
    result = { success: false, message: 'Lỗi hệ thống: ' + error.toString() };
  }
  return ContentService.createTextOutput(JSON.stringify(result)).setMimeType(ContentService.MimeType.JSON);
}

function initSystem() {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  
  // Lệnh này ép Google phải hỏi quyền gửi Mail khi bạn bấm Chạy
  const quota = MailApp.getRemainingDailyQuota();

  const configs = {
    'admin': ['ID', 'Email', 'MẬT KHẨU', 'HỌ VÀ TÊN', 'ID VAI TRÒ', 'TRẠNG THÁI', 'NGÀY ĐĂNG KÝ'],
    'use': ['ID', 'Email', 'MẬT KHẨU', 'HỌ VÀ TÊN', 'ID VAI TRÒ', 'GÁN AD MIND', 'TRẠNG THÁI', 'NGÀY ĐĂNG KÝ'],
    'roles_lookup': ['ID VAI TRÒ', 'TÊN VAI TRÒ', 'MÔ TẢ VAI TRÒ', 'DANH MỤC TRẠNG THÁI', 'DANH MỤC KẾT QUẢ LOG'],
    'otps': ['EMAIL', 'OTP', 'EXPIRE_TIME'],
    'phan_quyen': ['ID VAI TRÒ', 'TÊN VAI TRÒ', 'EMAIL QUẢN LÝ', 'CHECKIN_SALES', 'QUAN_LY_SAN_PHAM', 'DANH_SACH_DON_HANG', 'QUAN_LY_NHAN_VIEN', 'XEM_BANG_GIA', 'QUAN_LY_KHO']
  };

  for (let name in configs) {
    let sheet = ss.getSheetByName(name);
    if (!sheet) sheet = ss.insertSheet(name);
    if (sheet.getLastRow() === 0) {
        sheet.getRange(1, 1, 1, configs[name].length).setValues([configs[name]]);
    }
  }
  
  // Auto-migrate data to secure format during sync
  migrateAuthEmailsToEncrypted();

  return { success: true, message: 'Đã đồng bộ cấu trúc & Mã hóa dữ liệu thành công! Quota: ' + quota };
}

function getSheet(name) { return SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(name); }
function hashPassword(p) { return Utilities.computeDigest(Utilities.DigestAlgorithm.SHA_256, p).map(b => ('0' + (b & 0xFF).toString(16)).slice(-2)).join(''); }

// --- SECURITY CONFIG (XOR STANDARD) ---
const XOR_SECRET = 'dunvex_secure_key_2025_custom';
// Legacy AES Key
const AES_KEY = Utilities.newBlob('dunvex_secure_16').getBytes();

function encryptXOR(text) {
  if (!text) return "";
  try {
    const inputBytes = Utilities.newBlob(text.toString()).getBytes();
    const keyBytes = Utilities.newBlob(XOR_SECRET).getBytes();
    const outputBytes = [];
    for (let i = 0; i < inputBytes.length; i++) {
        outputBytes.push(inputBytes[i] ^ keyBytes[i % keyBytes.length]);
    }
    return Utilities.base64Encode(outputBytes);
  } catch (e) { return "ENC_ERR: " + e.toString(); }
}

function decryptXOR(base64Text) {
  if (!base64Text || base64Text.length < 5 || base64Text.startsWith("ENC_ERR")) return base64Text;
  try {
    const inputBytes = Utilities.base64Decode(base64Text);
    const keyBytes = Utilities.newBlob(XOR_SECRET).getBytes();
    const outputBytes = [];
    for (let i = 0; i < inputBytes.length; i++) {
        outputBytes.push(inputBytes[i] ^ keyBytes[i % keyBytes.length]);
    }
    return Utilities.newBlob(outputBytes).getDataAsString();
  } catch (e) { return base64Text; }
}

function decryptAES(base64Text) {
  if (!base64Text || base64Text.length < 10) return base64Text;
  try {
    const decoded = Utilities.base64Decode(base64Text);
    const decrypted = Utilities.decrypt(Utilities.CipherAlgorithm.AES_128, AES_KEY, decoded);
    return decrypted.getDataAsString();
  } catch (e) { return null; }
}

// Unified Encrypt (Default to XOR for new data)
function encryptData(text) {
  return encryptXOR(text);
}

// Unified Decrypt (Try XOR first, then AES)
function decryptData(base64Text) {
  let dec = decryptXOR(base64Text);
  // Heuristic: Valid email usually contains '@'. If XOR results in garbage, try AES.
  if ((!dec || !dec.includes('@')) && base64Text) {
     const aes = decryptAES(base64Text);
     if (aes && aes.includes('@')) return aes;
  }
  return dec || base64Text;
}

function handleSendOTP(data) {
  const email = (data.email || "").toString().trim().toLowerCase();
  const otp = Math.floor(100000 + Math.random() * 900000).toString();
  const expire = new Date(new Date().getTime() + 5 * 60000);
  const sheet = getSheet('otps');
  
  // Clean old OTPs (using decryption check to be safe)
  if(sheet.getLastRow() > 0) {
    const rows = sheet.getDataRange().getValues();
    for (let i = rows.length - 1; i >= 1; i--) {
        if (rows[i][0] && decryptData(rows[i][0]) === email) sheet.deleteRow(i + 1);
    }
  }
  
  // Save new OTP with XOR encryption
  const encEmail = encryptData(email);
  sheet.appendRow([encEmail, otp, expire]);
  
  try {
    MailApp.sendEmail({
      to: email,
      subject: "Mã xác thực Dunvex Account: " + otp,
      htmlBody: `
        <div style="font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; max-width: 500px; margin: 20px auto; border: 1px solid #6366f1; border-radius: 16px; padding: 40px 20px; box-sizing: border-box;">
          <h2 style="color: #6366f1; text-align: center; font-size: 24px; margin-bottom: 20px; font-weight: 800;">Xác thực OTP</h2>
          <p style="text-align: center; color: #475569; font-size: 15px; margin-bottom: 30px;">
            Chào bạn, đây là mã xác thực để bạn thực hiện thay đối trên hệ thống Dunvex:
          </p>
          <div style="background: #f0f7ff; border: 1px solid #6366f1; padding: 25px; text-align: center; border-radius: 12px; margin: 20px 0;">
            <span style="font-size: 48px; font-weight: 900; letter-spacing: 12px; color: #1e1b4b; display: block;">${otp}</span>
          </div>
          <p style="text-align: center; font-size: 12px; color: #94a3b8; margin-top: 30px;">
            Mã có hiệu lực trong 5 phút. Vui lòng bảo mật mã này.
          </p>
        </div>
      `
    });
    return { success: true, message: 'Đã gửi mã xác thực!' };
  } catch (e) { return { success: false, message: e.toString() }; }
}

function verifyOTP(email, otp) {
  const sheet = getSheet('otps');
  if(sheet.getLastRow() <= 1) return false;
  const rows = sheet.getDataRange().getValues();
  const now = new Date().getTime();
  const lowerEmail = email.toLowerCase();
  
  for (let i = 1; i < rows.length; i++) {
    const rowEmail = decryptData(rows[i][0]);
    if (rowEmail === lowerEmail && rows[i][1].toString() === otp.toString()) {
      if (now < new Date(rows[i][2]).getTime()) { sheet.deleteRow(i + 1); return true; }
    }
  }
  return false;
}

function handleRegister(data) {
  const email = data.email.toLowerCase();
  if (!verifyOTP(email, data.otp)) return { success: false, message: 'OTP sai' };
  const roleId = data.roleId || 'R005';
  const prefix = (roleId === 'R001' ? 'AD' : 'US');
  const sheetName = (roleId === 'R001' ? 'admin' : 'use');
  const id = generateNextId(sheetName, prefix);
  const encEmail = encryptData(email); // XOR
  if (roleId === 'R001') getSheet('admin').appendRow([id, encEmail, hashPassword(data.password), data.fullName, 'R001', 'Hoạt động', new Date()]);
  else getSheet('use').appendRow([id, encEmail, hashPassword(data.password), data.fullName, 'R005', 'N/A', 'Hoạt động', new Date()]);
  return { success: true };
}

function generateNextId(s, p) {
  const sheet = getSheet(s);
  if (sheet.getLastRow() <= 1) return p + '-001';
  const data = sheet.getRange("A:A").getValues();
  let max = 0;
  for (let i = 1; i < data.length; i++) {
    const val = data[i][0].toString();
    if (val.includes('-')) {
      const n = parseInt(val.split('-').pop());
      if (n > max) max = n;
    }
  }
  return p + '-' + (max + 1).toString().padStart(3, '0');
}

function isEmailExists(e) {
  const searchEmail = e.toString().toLowerCase();
  for (let s of ['admin', 'use']) {
    const sheet = getSheet(s);
    if (sheet.getLastRow() <= 1) continue;
    const rows = sheet.getDataRange().getValues();
    for (let i = 1; i < rows.length; i++) {
        if (decryptData(rows[i][1]) === searchEmail) return true;
    }
  }
  return false;
}

function handleLogin(data) {
  const email = (data.email || "").toString().trim().toLowerCase();
  const password = (data.password || "").toString().trim();
  const hashedPassword = hashPassword(password);
  let user = findUserInSheet('admin', email, hashedPassword) || findUserInSheet('use', email, hashedPassword, true);
  if (!user) return { success: false, message: 'Sai thông tin (Email/Mật khẩu)' };

  let adminOfThisUser = email; // Default for Admins (plain email for memory)
  if (user.id.startsWith('US')) {
     const useData = getSheet('use').getDataRange().getValues();
     const useRow = useData.find(r => decryptData(r[1]) === email);
     if (useRow) adminOfThisUser = decryptData(useRow[5]); // Decrypt the assigned admin email
  }
  user.adminEmail = adminOfThisUser;
  return { success: true, user: user, permissions: getPermissions(user.roleId, adminOfThisUser) };
}

function getPermissions(roleId, adminEmail = "ALL") {
  const sheet = getSheet('phan_quyen');
  if(!sheet || sheet.getLastRow() <= 1) return null;
  const rows = sheet.getDataRange().getValues();
  let pRes = null;
  let gRes = null;
  const safeAdmin = (adminEmail || "").toLowerCase().trim();

  for (let i = 1; i < rows.length; i++) {
    if (rows[i][0] == roleId) {
      const p = { 
        checkinSales: !!rows[i][3], 
        quanLySanPham: !!rows[i][4], 
        danhSachDonHang: !!rows[i][5],
        quanLyNhanVien: !!rows[i][6],
        xemBangGia: !!rows[i][7],
        quanLyKho: !!rows[i][8]
      };
      
      const rowAdmin = decryptData(rows[i][2]).toLowerCase();
      if (rowAdmin === safeAdmin) pRes = p;
      if (rowAdmin === 'all') gRes = p;
    }
  }
  return pRes || gRes;
}

function findUserInSheet(sName, e, h, isU = false) {
  const sheet = getSheet(sName);
  if (sheet.getLastRow() <= 1) return null;
  const rows = sheet.getDataRange().getValues();
  const searchEmail = e.toString().trim().toLowerCase();
  
  for (let i = 1; i < rows.length; i++) {
    // Decrypt email to handle AES, XOR or Plain
    const rowEmail = decryptData(rows[i][1]).toLowerCase();
    const rowPass = (rows[i][2] || "").toString().trim();
    
    if (rowEmail === searchEmail && rowPass === h) {
      return { 
        id: rows[i][0], 
        email: rowEmail, 
        fullName: rows[i][3], 
        roleId: rows[i][4], 
        status: isU ? rows[i][6] : rows[i][5] 
      };
    }
  }
  return null;
}

function getRoles() {
  const sheet = getSheet('roles_lookup');
  if (sheet.getLastRow() <= 1) return { success: true, roles: [] };
  const rows = sheet.getDataRange().getValues();
  const roles = [];
  for (let i = 1; i < rows.length; i++) if (rows[i][0]) roles.push({ id: rows[i][0], name: rows[i][1] });
  return { success: true, roles: roles };
}

function getUsers(d) {
  const sheet = getSheet('use');
  if (sheet.getLastRow() <= 1) return { success:true, users:[] };
  const rows = sheet.getDataRange().getValues();
  const adminEmail = (d.adminEmail || "").toLowerCase().trim();
  const users = [];
  
  for (let i = 1; i < rows.length; i++) {
    // Filter by assigned Admin (Decrypt first to support AES/XOR checks)
    const assignedAdmin = (decryptData(rows[i][5]) || "").toLowerCase();
    
    if (assignedAdmin === adminEmail) {
      users.push({ 
        id: rows[i][0], 
        email: decryptData(rows[i][1]), // Return decrypted for display/editing
        fullName: rows[i][3], 
        roleId: rows[i][4], 
        status: rows[i][6] 
      });
    }
  }
  return { success: true, users: users };
}

function handleUpdateRole(d) {
  const s = getSheet('use');
  const rows = s.getDataRange().getValues();
  const searchEmail = d.userEmail.toLowerCase().trim();
  
  for (let i = 1; i < rows.length; i++) {
      if (decryptData(rows[i][1]) === searchEmail) { 
          s.getRange(i + 1, 5).setValue(d.newRoleId);
          // Also migrate email to new encryption
          s.getRange(i + 1, 2).setValue(encryptData(searchEmail));
          return { success: true }; 
      }
  }
  return { success: false };
}

function handleCreateUser(d) {
  if (isEmailExists(d.email)) return { success: false, message: 'Đã tồn tại' };
  const id = generateNextId('use', 'US');
  const encEmail = encryptData(d.email); // XOR
  const encAdmin = encryptData(d.adminEmail); // XOR
  getSheet('use').appendRow([id, encEmail, hashPassword(d.password || '123456'), d.fullName, d.roleId, encAdmin, 'Hoạt động', new Date()]);
  return { success: true };
}

function handleResetPassword(d) {
  const email = (d.email || "").toString().trim().toLowerCase();
  const newPass = (d.newPassword || "").toString().trim();
  
  if (!verifyOTP(email, d.otp)) return { success: false, message: 'OTP sai hoặc hết hạn' };
  
  // Need to search decryption-based because we don't know if stored format is AES or XOR
  for (let name of ['admin', 'use']) {
    const sheet = getSheet(name);
    if (sheet.getLastRow() <= 1) continue;
    const rows = sheet.getDataRange().getValues();
    for (let i = 1; i < rows.length; i++) {
      const rowEmail = decryptData(rows[i][1]).toLowerCase();
      if (rowEmail === email) {
        sheet.getRange(i + 1, 3).setValue(hashPassword(newPass));
        return { success: true };
      }
    }
  }
  return { success: false, message: 'Không tìm thấy tài khoản với email này' };
}
function getPhanQuyen() {
  try {
    const sheet = getSheet('phan_quyen');
    if (!sheet) return { success: false, message: 'Sheet phan_quyen không tồn tại' };
    const rows = sheet.getDataRange().getValues();
    const data = [];
    const headers = ['id_vai_tro', 'ten_vai_tro', 'email_quan_ly', 'checkin_sales', 'quan_ly_san_pham', 'danh_sach_don_hang', 'quan_ly_nhan_vien', 'xem_bang_gia', 'quan_ly_kho'];
    
    for (let i = 1; i < rows.length; i++) {
      let obj = {};
      headers.forEach((h, idx) => {
        let val = rows[i][idx];
        if (h === 'email_quan_ly') {
          val = decryptData(val);
        }
        obj[h] = val;
      });
      data.push(obj);
    }
    return { success: true, data: data };
  } catch (e) {
    return { success: false, message: e.toString() };
  }
}

function savePhanQuyen(d) {
  try {
    const sheet = getSheet('phan_quyen');
    const rows = sheet.getDataRange().getValues();
    const roleId = d.id_vai_tro;
    const adminEmail = (d.email_quan_ly || 'ALL').toString().trim().toLowerCase();
    
    // Check using Decryption to match existing rows regardless of encryption
    for (let i = 1; i < rows.length; i++) {
      const rowAdmin = decryptData(rows[i][2]).toLowerCase();
      if (rows[i][0] == roleId && rowAdmin === adminEmail) {
        sheet.getRange(i + 1, 4, 1, 6).setValues([[
          d.checkin_sales === true,
          d.quan_ly_san_pham === true,
          d.danh_sach_don_hang === true,
          d.quan_ly_nhan_vien === true,
          d.xem_bang_gia === true,
          d.quan_ly_kho === true
        ]]);
        return { success: true };
      }
    }
    
    // Nếu chưa có thì thêm mới (Use XOR)
    const encAdmin = encryptData(adminEmail);
    sheet.appendRow([
      roleId, 
      d.ten_vai_tro || 'Vai trò mới', 
      encAdmin, 
      d.checkin_sales === true,
      d.quan_ly_san_pham === true,
      d.danh_sach_don_hang === true,
      d.quan_ly_nhan_vien === true,
      d.xem_bang_gia === true,
      d.quan_ly_kho === true
    ]);
    return { success: true };
  } catch (e) {
    return { success: false, message: e.toString() };
  }
}

// --- MIGRATION UTILITY (RUN ONCE TO SECURE EXISTING DATA) ---
function migrateAuthEmailsToEncrypted() {
  const configs = [
    { sheet: 'admin', cols: [1] },
    { sheet: 'use', cols: [1, 5] },
    { sheet: 'otps', cols: [0] },
    { sheet: 'phan_quyen', cols: [2] },
    { sheet: 'logs', cols: [3, 5] } // Encrypt Email (D) and Performer (F)
  ];

  configs.forEach(conf => {
    const sheet = getSheet(conf.sheet);
    if (!sheet || sheet.getLastRow() < 2) return;
    const rows = sheet.getDataRange().getValues();

    for (let i = 1; i < rows.length; i++) {
      conf.cols.forEach(idx => {
        const val = (rows[i][idx] || "").toString();
        // Encrypt if it looks like an email and isn't already a long base64 string
        if (val.includes('@') && !val.includes(' ') && val.length < 50) { 
          sheet.getRange(i + 1, idx + 1).setValue(encryptData(val.toLowerCase()));
        }
      });
    }
  });
  return "Auth Migration Complete!";
}
