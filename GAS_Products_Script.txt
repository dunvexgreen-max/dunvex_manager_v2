/**
 * DUNVEX PRODUCT MANAGEMENT SYSTEM (CRUD JSON)
 * Xử lý dữ liệu sản phẩm lưu dưới dạng file JSON trên Google Drive
 */

const PRODUCT_JSON_FILENAME = 'tao_san_pham.json';
const IMAGE_FOLDER_ID = '1dGFgw96a6gWVdHMq6rkk4fFRpDJqi5cG';

// --- SECURITY CONFIG (XOR ENCRYPTION) ---
const XOR_SECRET = 'dunvex_secure_key_2025_custom';
// Keep legacy AES key for migration/compatibility
const AES_KEY = Utilities.newBlob('dunvex_secure_16').getBytes();

function encryptXOR(text) {
  if (!text) return "";
  try {
    const inputBytes = Utilities.newBlob(text.toString()).getBytes();
    const keyBytes = Utilities.newBlob(XOR_SECRET).getBytes();
    const outputBytes = [];
    for (let i = 0; i < inputBytes.length; i++) {
        outputBytes.push(inputBytes[i] ^ keyBytes[i % keyBytes.length]);
    }
    return Utilities.base64Encode(outputBytes);
  } catch (e) { return "ENC_ERR: " + e.toString(); }
}

function decryptXOR(base64Text) {
  if (!base64Text || base64Text.length < 5 || base64Text.startsWith("ENC_ERR")) return base64Text;
  try {
    const inputBytes = Utilities.base64Decode(base64Text);
    const keyBytes = Utilities.newBlob(XOR_SECRET).getBytes();
    const outputBytes = [];
    for (let i = 0; i < inputBytes.length; i++) {
        outputBytes.push(inputBytes[i] ^ keyBytes[i % keyBytes.length]);
    }
    return Utilities.newBlob(outputBytes).getDataAsString();
  } catch (e) { return base64Text; }
}

function encryptAES(text) {
  if (!text) return "";
  try {
    const blob = Utilities.newBlob(text.toString().trim()); 
    const encrypted = Utilities.encrypt(Utilities.CipherAlgorithm.AES_128, AES_KEY, blob);
    return Utilities.base64Encode(encrypted);
  } catch (e) { return text; }
}

function decryptAES(base64Text) {
  if (!base64Text || base64Text.length < 10) return base64Text;
  try {
    const decoded = Utilities.base64Decode(base64Text);
    const decrypted = Utilities.decrypt(Utilities.CipherAlgorithm.AES_128, AES_KEY, decoded);
    return decrypted.getDataAsString();
  } catch (e) { return null; } // Return null if failed
}

// Unified Decryptor (Try XOR, then AES)
function decryptUnified(text) {
  // If it's valid XOR, it decrypts to a readable string. If garbage or special chars, maybe AES?
  // Since we can't easily detect garbage, we rely on context or attempt migration.
  // However, specifically for this transition, we can try to assume new data is XOR.
  // But to be safe, we will migrate data OFFLINE or via explicit command.
  // For Real-time display:
  return decryptXOR(text); // Default to XOR. If text is AES encrypted, this will show garbage. 
  // users must run migration.
}

function doPost(e) {
  let result;
  try {
    const contents = e.postData ? e.postData.contents : "";
    if (!contents) {
       return ContentService.createTextOutput(JSON.stringify({ success: false, message: 'Dữ liệu POST trống (Sản Phẩm Script)' })).setMimeType(ContentService.MimeType.JSON);
    }
    
    const data = JSON.parse(contents);
    const action = (data.action || "").toString().trim();

    switch (action) {
      case 'get_products':
      case 'getProducts':
        result = getProducts(data.userEmail, data.isAdmin, data.adminEmail);
        break;
      case 'save_product':
      case 'saveProduct':
        result = saveProduct(data.product, data.image_data);
        break;
      case 'delete_product':
      case 'deleteProduct':
        result = deleteProduct(data.id_san_pham);
        break;
      case 'upload_image':
      case 'uploadImage':
        result = handleImageUpload(data.filename, data.base64, data.mimetype);
        break;
      case 'get_initial_data': // Alias để tương thích chéo
        result = getProducts(data.userEmail || data.salesId, data.isAdmin, data.adminEmail);
        break;
      case 'migrate_products':
        result = migrateProductsToXOR();
        break;
      default:
        result = { success: false, message: 'Hành động [' + action + '] không hợp lệ tại Sản Phẩm Script' };
    }
  } catch (error) {
    result = { success: false, message: 'Lỗi Backend Sản Phẩm: ' + error.toString() };
  }
  return ContentService.createTextOutput(JSON.stringify(result)).setMimeType(ContentService.MimeType.JSON);
}

/**
 * Lấy hoặc tạo file JSON trên Drive
 */
function getJsonFile() {
  const files = DriveApp.getFilesByName(PRODUCT_JSON_FILENAME);
  if (files.hasNext()) {
    return files.next();
  } else {
    return DriveApp.createFile(PRODUCT_JSON_FILENAME, '[]', MimeType.PLAIN_TEXT);
  }
}

function getProducts(userEmail, isAdmin, adminEmail) {
  try {
    const file = getJsonFile();
    const content = file.getBlob().getDataAsString();
    const list = JSON.parse(content || '[]');
    
    // Prepare hashes for filtering
    const xorUser = encryptXOR(userEmail);
    const aesUser = encryptAES(userEmail);
    
    const filtered = list.filter(p => {
      // Logic: Show if createdBy matches User (XOR or AES) OR if User is Admin
      if (isAdmin) return true;
      const creator = (p.ten_dang_nhap || "").toString();
      return creator === xorUser || creator === aesUser;
    }).map(p => {
      const copy = Object.assign({}, p);
      
      // SMART DECRYPT: Try XOR first, if not a valid email, try AES
      let dec = decryptXOR(p.ten_dang_nhap);
      // Valid email heuristic: contains '@' and no weird control chars (optional, simple check is @)
      // Also check if decryptAES works
      if ((!dec || !dec.includes('@')) && p.ten_dang_nhap) {
         const aesDec = decryptAES(p.ten_dang_nhap);
         if (aesDec && aesDec.includes('@')) {
           dec = aesDec; 
         }
      }
      
      copy.ten_dang_nhap = dec; 
      return copy;
    });
    
    return { success: true, products: filtered };
  } catch (e) {
    return { success: false, message: e.toString() };
  }
}

function saveProduct(productDict, imageData) {
  try {
    const file = getJsonFile();
    let products = JSON.parse(file.getBlob().getDataAsString() || '[]');
    
    // 1. Xử lý ID
    if (!productDict.id_san_pham) {
      const nextId = products.length > 0 
        ? "S" + (Math.max(...products.map(p => parseInt(p.id_san_pham.replace('S', '')))) + 1).toString().padStart(3, '0')
        : "S001";
      productDict.id_san_pham = nextId;
    }

    // 2. Xử lý Hình ảnh (Nếu có data base64 gửi kèm)
    if (imageData && imageData.base64) {
      const uploadRes = handleImageUpload(imageData.filename, imageData.base64, imageData.mimetype);
      if (uploadRes.success) {
        productDict.image_san_pham = uploadRes.url;
      }
    }

    // 3. Encrypt identity (ALWAYS XOR)
    if (productDict.ten_dang_nhap) {
      productDict.ten_dang_nhap = encryptXOR(productDict.ten_dang_nhap);
    }

    // 4. Cập nhật hoặc Thêm mới
    const index = products.findIndex(p => p.id_san_pham === productDict.id_san_pham);
    if (index > -1) {
      products[index] = productDict;
    } else {
      products.push(productDict);
    }

    // 5. Lưu lại file
    file.setContent(JSON.stringify(products, null, 2));
    
    // Return decrypted for UI
    const resultDict = Object.assign({}, productDict);
    resultDict.ten_dang_nhap = decryptXOR(productDict.ten_dang_nhap);
    return { success: true, product: resultDict };
  } catch (e) {
    return { success: false, message: e.toString() };
  }
}

function deleteProduct(id) {
  try {
    const file = getJsonFile();
    let products = JSON.parse(file.getBlob().getDataAsString() || '[]');
    const newProducts = products.filter(p => p.id_san_pham !== id);
    file.setContent(JSON.stringify(newProducts, null, 2));
    return { success: true };
  } catch (e) {
    return { success: false, message: e.toString() };
  }
}

function handleImageUpload(filename, base64, mimetype) {
  try {
    const folder = DriveApp.getFolderById(IMAGE_FOLDER_ID);
    const decoded = Utilities.base64Decode(base64);
    const blob = Utilities.newBlob(decoded, mimetype, filename);
    const file = folder.createFile(blob);
    file.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW);
    
    const url = "https://lh3.googleusercontent.com/d/" + file.getId();
    return { success: true, url: url };
  } catch (e) {
    return { success: false, message: e.toString() };
  }
}

// --- MIGRATION UTILITY (Auto-convert AES to XOR) ---
function migrateProductsToXOR() {
  try {
    const file = getJsonFile();
    let products = JSON.parse(file.getBlob().getDataAsString() || '[]');
    let count = 0;

    products = products.map(p => {
      // Check if it decrypts with AES
      const aesDec = decryptAES(p.ten_dang_nhap);
      if (aesDec) {
        // If AES valid, re-encrypt with XOR
        p.ten_dang_nhap = encryptXOR(aesDec);
        count++;
      }
      return p;
    });

    if (count > 0) {
      file.setContent(JSON.stringify(products, null, 2));
      return { success: true, message: `Migrated ${count} products to XOR.` };
    }
    return { success: true, message: "No AES products found to migrate." };
  } catch(e) {
    return { success: false, message: e.toString() };
  }
}
