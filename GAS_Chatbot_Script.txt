/**
 * DUNVEX CHATBOT & MESSAGING SYSTEM (PREMIUM)
 * Enhanced for real-time messaging, image uploads, and admin controls.
 */

const DATA_FOLDER_ID = '1_LT4rzVui2E3BgfcwUSfMsUGQMN9NRTs'; 
const IMAGE_FOLDER_ID = '1dGFgw96a6gWVdHMq6rkk4fFRpDJqi5cG'; // User specified folder
const HISTORY_FILE = 'chat_messages.json';
const XOR_SECRET = 'dunvex_secure_key_2025_custom';

// Encryption Utils (Consistent with Auth)
function encryptData(text) {
  if (!text) return "";
  const inputBytes = Utilities.newBlob(text.toString()).getBytes();
  const keyBytes = Utilities.newBlob(XOR_SECRET).getBytes();
  const outputBytes = [];
  for (let i = 0; i < inputBytes.length; i++) {
    outputBytes.push(inputBytes[i] ^ keyBytes[i % keyBytes.length]);
  }
  return Utilities.base64Encode(outputBytes);
}

function decryptData(text) {
  if (!text || text === 'n/a') return "";
  try {
    const bytes = Utilities.base64Decode(text.toString().trim());
    const keyBytes = Utilities.newBlob(XOR_SECRET).getBytes();
    let result = "";
    for (let i = 0; i < bytes.length; i++) {
        result += String.fromCharCode(bytes[i] ^ keyBytes[i % keyBytes.length]);
    }
    return result;
  } catch (e) { return text; }
}

const SafeStore = {
  read: function(filename) {
    try {
      const folder = DriveApp.getFolderById(DATA_FOLDER_ID);
      const files = folder.getFilesByName(filename);
      if (!files.hasNext()) return [];
      const content = files.next().getBlob().getDataAsString().trim();
      if (!content) return [];
      
      return content.split('\n').filter(l => l.trim()).map(l => JSON.parse(l));
    } catch (e) { return []; }
  },
  write: function(filename, newData, action = 'APPEND') {
    const lock = LockService.getScriptLock();
    try {
      lock.waitLock(30000);
      const folder = DriveApp.getFolderById(DATA_FOLDER_ID);
      let file, files = folder.getFilesByName(filename);
      if (files.hasNext()) file = files.next();
      else file = folder.createFile(filename, '', MimeType.PLAIN_TEXT);

      let data = action === 'REPLACE_ALL' ? newData : this.read(filename);
      if (action === 'APPEND') data.push(newData);
      
      file.setContent(data.map(item => JSON.stringify(item)).join('\n'));
      return { success: true };
    } catch (e) { 
      return { success: false, message: e.toString() }; 
    } finally {
      lock.releaseLock();
    }
  }
};

function doPost(e) {
  try {
    const data = JSON.parse(e.postData.contents);
    const intent = data.action;
    let result;

    switch(intent) {
      case 'send_msg': result = handleSendMessage(data); break;
      case 'get_history': result = getHistory(data.email); break;
      case 'master_get_all': result = masterGetAllChats(); break;
      case 'master_reply': result = masterReply(data); break;
      case 'edit_msg': result = editMessage(data); break;
      case 'delete_msg': result = deleteMessage(data); break;
      default: result = { success: false, message: 'HÃ nh Ä‘á»™ng khÃ´ng xÃ¡c Ä‘á»‹nh' };
    }
    return ContentService.createTextOutput(JSON.stringify(result)).setMimeType(ContentService.MimeType.JSON);
  } catch (error) {
    return ContentService.createTextOutput(JSON.stringify({ success: false, message: error.toString() })).setMimeType(ContentService.MimeType.JSON);
  }
}

function handleSendMessage(d) {
  let fileUrl = "";
  if (d.image) {
    try {
      const folder = DriveApp.getFolderById(IMAGE_FOLDER_ID);
      const blob = Utilities.newBlob(Utilities.base64Decode(d.image.split(',')[1]), d.imageType || "image/png", "chat_img_" + new Date().getTime());
      const file = folder.createFile(blob);
      file.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW);
      fileUrl = file.getUrl().replace("view?usp=drivesdk", "uc?export=view&id=") + file.getId();
    } catch (e) { return { success: false, message: "Lá»—i táº£i áº£nh: " + e.toString() }; }
  }

  const entry = {
    id: "MSG_" + new Date().getTime() + "_" + Math.floor(Math.random() * 1000),
    email: encryptData(d.email.toLowerCase()),
    senderName: d.fullName || "KhÃ¡ch",
    text: d.text || "",
    image: fileUrl,
    type: "user",
    timestamp: new Date().toISOString()
  };

  return SafeStore.write(HISTORY_FILE, entry, 'APPEND');
}

function getHistory(email) {
  const enc = encryptData(email.toLowerCase());
  const all = SafeStore.read(HISTORY_FILE);
  const filtered = all.filter(m => m.email === enc);
  return { success: true, history: filtered };
}

function masterGetAllChats() {
  const all = SafeStore.read(HISTORY_FILE);
  // Group by decrypted email
  const convos = {};
  all.forEach(m => {
    const rawEmail = decryptData(m.email);
    if (!convos[rawEmail]) convos[rawEmail] = { email: rawEmail, lastMsg: "", lastTime: "", unread: 0, messages: [] };
    convos[rawEmail].messages.push(m);
    convos[rawEmail].lastMsg = m.text || "ðŸ“· HÃ¬nh áº£nh";
    convos[rawEmail].lastTime = m.timestamp;
  });
  return { success: true, conversations: Object.values(convos) };
}

function masterReply(d) {
  const entry = {
    id: "MSG_" + new Date().getTime() + "_" + Math.floor(Math.random() * 1000),
    email: encryptData(d.userEmail.toLowerCase()),
    senderName: "Super Admin",
    text: d.text || "",
    image: d.image || "",
    type: "admin",
    timestamp: new Date().toISOString()
  };
  return SafeStore.write(HISTORY_FILE, entry, 'APPEND');
}

function editMessage(d) {
  const all = SafeStore.read(HISTORY_FILE);
  const idx = all.findIndex(m => m.id === d.msgId);
  if (idx === -1) return { success: false, message: "KhÃ´ng tÃ¬m tháº¥y tin nháº¯n" };
  
  all[idx].text = d.newText;
  all[idx].isEdited = true;
  return SafeStore.write(HISTORY_FILE, all, 'REPLACE_ALL');
}

function deleteMessage(d) {
  const all = SafeStore.read(HISTORY_FILE);
  const filtered = all.filter(m => m.id !== d.msgId);
  return SafeStore.write(HISTORY_FILE, filtered, 'REPLACE_ALL');
}
