/**
 * GAS SCRIPT CHO QUẢN LÝ SẢN PHẨM KHÁCH HÀNG (data_san_pham_kh)
 * Phiên bản: SỬA LỖI MẤT ID KHI SYNC JSON & SHEET
 * 
 * SHEET STRUCTURE (ton_kho):
 * Col A: date (ngày nhập/xuất)
 * Col B: ten_san_pham (tên sản phẩm)
 * Col C: id_san_pham (ID sản phẩm)
 * Col D: so_luong_nhap (số lượng nhập)
 * Col E: trang_thai (trạng thái: nhập/xuất)
 * Col F: con_lai (còn lại)
 * Col G: trang_thai_xoa (trạng thái xóa - dùng cho edit/delete)
 * Col H: ten_dang_nhap (tên đăng nhập) -- IMPORTANT: Must add this column!
 */

const SPREADSHEET_ID = '1x_DgdgVJVjkzZt8_e7Zg0gqDnG7oHmV0H7DgebVzD3E';
const SHEET_NAME = 'data_san_pham_kh';
const INVENTORY_SHEET_NAME = 'ton_kho';
const IMAGE_FOLDER_ID = '1iIG2DNVH7hYKG0z74oDGaY3ndGWLqu_S';

function doGet(e) {
  try {
    const params = e.parameter;
    if (params.action === 'read') return readData(params.username);
    if (params.action === 'readInventory') return readInventory(params.username);
    return jsonResponse({success: false, message: 'Invalid GET action'});
  } catch (err) {
    return jsonResponse({success: false, message: err.toString()});
  }
}

function doPost(e) {
  let data = null;
  // Try parse raw post body (JSON)
  try {
    if (e.postData && e.postData.contents) data = JSON.parse(e.postData.contents);
  } catch (err) {
    data = null;
  }

  // If not JSON, try form-encoded field 'payload' (payload=JSON.stringify(...))
  try {
    if (!data && e.parameter && e.parameter.payload) {
      data = JSON.parse(e.parameter.payload);
    }
  } catch (err) {
    data = null;
  }

  // If still no data, try to build from parameters directly (simple form)
  if (!data && e.parameter && Object.keys(e.parameter).length > 0) {
    // copy e.parameter into data with action and data keys if present
    data = {};
    if (e.parameter.action) data.action = e.parameter.action;
    if (e.parameter.data) {
      try { data.data = JSON.parse(e.parameter.data); } catch (err) { data.data = e.parameter.data; }
    } else {
      // assemble data.* from parameter keys (strip known meta keys)
      const metaKeys = ['action','payload','callback','_'];
      const obj = {};
      Object.keys(e.parameter).forEach(k => {
        if (metaKeys.indexOf(k) === -1) obj[k] = e.parameter[k];
      });
      if (Object.keys(obj).length > 0) data.data = obj;
    }
  }

  if (!data) return jsonResponse({success: false, message: 'Invalid POST body or missing payload'});

  try {
    if (data.action === 'upload') return uploadFile(data);
    if (data.action === 'create') return createData(data);
    if (data.action === 'update') return updateData(data);
    if (data.action === 'delete') return deleteData(data);
    if (data.action === 'createInventory') return createInventory(data);
    if (data.action === 'updateInventory') return updateInventory(data);
    return jsonResponse({success: false, message: 'Invalid POST action'});
  } catch (err) {
    return jsonResponse({success: false, message: err.toString()});
  }
}

function normalizeHeader(h) {
  return String(h || '').trim()
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '')
    .replace(/\s+/g, '')
    .toLowerCase();
}

function normalizeDataKeys(obj) {
  const out = {};
  if (!obj) return out;
  Object.keys(obj).forEach(k => {
    const nk = normalizeHeader(k);
    out[nk] = obj[k];
  });
  return out;
}

// Map a normalized header to a canonical field name used by the payload
function canonicalizeHeader(normH) {
  if (!normH) return normH;
  // normalize header token: remove non-alphanumeric characters (underscores, spaces, punctuation)
  const token = String(normH).toLowerCase().replace(/[^a-z0-9]/g, '');

  // common canonical keys (tokens without separators)
  const keys = {
    ten_san_pham: ['tensanpham'],
    id_san_pham: ['idsanpham'],
    so_luong_nhap: ['soluongnhap', 'soluong'],
    so_luong_xuat: ['soluongxuat', 'soluongx'],
    con_lai: ['conlai'],
    ghi_chu: ['ghichu'],
    ten_dang_nhap: ['tendangnhap'],
    trang_thai: ['trangthai'],
    trang_thai_xoa: ['trangthaixoa'],
    ten_nganh_hang: ['tennganhhang', 'tennghanhhang', 'nganhhang']
  };

  // direct token matches
  for (const canon in keys) {
    if (keys[canon].indexOf(token) !== -1) return canon;
  }

  // substring heuristics on token
  if (token.indexOf('tensanpham') !== -1 || (token.indexOf('ten') !== -1 && token.indexOf('san') !== -1)) return 'ten_san_pham';
  if (token.indexOf('id') !== -1 && token.indexOf('san') !== -1) return 'id_san_pham';
  if (token.indexOf('nhap') !== -1) return 'so_luong_nhap';
  if (token.indexOf('xuat') !== -1) return 'so_luong_xuat';
  if (token.indexOf('con') !== -1 && token.indexOf('lai') !== -1) return 'con_lai';
  if (token.indexOf('ghi') !== -1) return 'ghi_chu';
  if (token.indexOf('dangnhap') !== -1 || token.indexOf('tendangnhap') !== -1) return 'ten_dang_nhap';
  if (token.indexOf('trangthai') !== -1) return 'trang_thai';

  // fallback: if token contains 'soluong' but not nhap/xuat, treat as nhập
  if (token.indexOf('soluong') !== -1) return 'so_luong_nhap';

  // as last resort, return original normalized header
  return normH;
}

function readData(username) {
  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const sheet = ss.getSheetByName(SHEET_NAME);
    const lastRow = sheet.getLastRow();
    if (lastRow < 1) return jsonResponse({success: true, data: []});
    
    const values = sheet.getDataRange().getValues();
    const headers = values[0].map(normalizeHeader);
    const data = [];
    
    for (let i = 1; i < values.length; i++) {
        let obj = {};
        headers.forEach((header, index) => { if (header) obj[header] = values[i][index]; });
        if (obj['ten_dang_nhap'] === username) {
          data.push(obj);
        }
    }
    return jsonResponse({success: true, data: data});
  } catch (err) { return jsonResponse({success: false, message: err.toString()}); }
}

function createData(payload) {
  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const sheet = ss.getSheetByName(SHEET_NAME);
    const lastRow = sheet.getLastRow();
    const rawHeaders = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    const headers = rawHeaders.map(normalizeHeader);
    // Normalize incoming payload keys
    const normalizedPayload = normalizeDataKeys(payload.data || {});

    // Nếu payload không có ID, tự tạo ID mới theo format S001
    if (!normalizedPayload['id_san_pham']) {
      let nextNum = 1;
      const idIdx = headers.indexOf('id_san_pham');
      if (idIdx !== -1 && lastRow > 1) {
        const ids = sheet.getRange(2, idIdx + 1, lastRow - 1, 1).getValues().flat();
        const nums = ids.map(id => {
          const m = String(id).match(/S(\d+)/);
          return m ? parseInt(m[1]) : 0;
        });
        nextNum = Math.max(...nums, 0) + 1;
      }
      normalizedPayload['id_san_pham'] = 'S' + String(nextNum).padStart(3, '0');
      // also set into original payload for compatibility
      payload.data = payload.data || {};
      payload.data.id_san_pham = normalizedPayload['id_san_pham'];
    }

    // Build canonical header mapping
    const canonicalHeaders = headers.map(h => canonicalizeHeader(h));

    const newRow = rawHeaders.map((h, i) => {
      const canon = canonicalHeaders[i];
      if (normalizedPayload[canon] !== undefined) return normalizedPayload[canon];
      const normH = headers[i];
      return normalizedPayload[normH] !== undefined ? normalizedPayload[normH] : '';
    });

    sheet.appendRow(newRow);

    // Return written row for debugging
    const written = {};
    rawHeaders.forEach((h, i) => { written[h] = newRow[i]; });
    return jsonResponse({success: true, id: normalizedPayload['id_san_pham'], row: written});
  } catch (err) { return jsonResponse({success: false, message: err.toString()}); }
}

function updateData(payload) {
  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const sheet = ss.getSheetByName(SHEET_NAME);
    const values = sheet.getDataRange().getValues();
    const rawHeaders = values[0];
    const headers = rawHeaders.map(normalizeHeader);
    const idIdx = headers.indexOf('id_san_pham');
    const normalizedPayload = normalizeDataKeys(payload.data || {});

    
    let foundRow = -1;
    for (let i = 1; i < values.length; i++) {
      if (String(values[i][idIdx]).trim() === String(payload.idValue).trim()) {
        foundRow = i + 1;
        break;
      }
    }
    
    if (foundRow !== -1) {
      // Nếu tìm thấy row, cập nhật
      const canonicalHeaders = headers.map(h => canonicalizeHeader(h));
      headers.forEach((h, index) => {
        const canon = canonicalHeaders[index];
        if (h) {
          if (normalizedPayload[canon] !== undefined) {
            sheet.getRange(foundRow, index + 1).setValue(normalizedPayload[canon]);
          } else if (normalizedPayload[h] !== undefined) {
            sheet.getRange(foundRow, index + 1).setValue(normalizedPayload[h]);
          }
        }
      });
    } else {
      // Nếu không thấy (Data từ JSON), thêm dòng mới vào Sheet
      const canonicalHeaders = headers.map(h => canonicalizeHeader(h));
      const newRow = rawHeaders.map((h, i) => {
        const canon = canonicalHeaders[i];
        if (normalizedPayload[canon] !== undefined) return normalizedPayload[canon];
        const normH = headers[i];
        return normalizedPayload[normH] !== undefined ? normalizedPayload[normH] : '';
      });
      sheet.appendRow(newRow);
    }
    
    // Build debug mapping for response
    const respRow = {};
    const cols = sheet.getRange(1,1,1,sheet.getLastColumn()).getValues()[0];
    cols.forEach((c,i)=>{ respRow[c] = (foundRow!==-1) ? sheet.getRange(foundRow, i+1).getValue() : newRow[i]; });
    return jsonResponse({success: true, row: respRow});
  } catch (err) { return jsonResponse({success: false, message: err.toString()}); }
}

function deleteData(payload) {
  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const sheet = ss.getSheetByName(SHEET_NAME);
    const values = sheet.getDataRange().getValues();
    const rawHeaders = values[0];
    const headers = rawHeaders.map(normalizeHeader);
    const idIdx = headers.indexOf('id_san_pham');
    const delIdx = headers.indexOf('trang_thai_xoa_sp');
    
    if (idIdx === -1 || delIdx === -1) throw new Error('Cột id_san_pham hoặc trang_thai_xoa_sp không tồn tại');

    let foundRow = -1;
    for (let i = 1; i < values.length; i++) {
      if (String(values[i][idIdx]).trim() === String(payload.idValue).trim()) {
        foundRow = i + 1;
        break;
      }
    }
    
    if (foundRow !== -1) {
      sheet.getRange(foundRow, delIdx + 1).setValue('DELETED');
    } else if (payload.data) {
      // Nếu là data JSON chưa có trong Sheet, copy data đó vào Sheet với trạng thái DELETED
      const normalizedPayload = normalizeDataKeys(payload.data || {});
      const canonicalHeaders = headers.map(h => canonicalizeHeader(h));
      const fullData = Object.assign({}, normalizedPayload, {trang_thai_xoa_sp: 'DELETED'});
      const newRow = rawHeaders.map((h, i) => {
        const canon = canonicalHeaders[i];
        if (fullData[canon] !== undefined) return fullData[canon];
        const normH = headers[i];
        return fullData[normH] !== undefined ? fullData[normH] : '';
      });
      sheet.appendRow(newRow);
    }
    
    return jsonResponse({success: true});
  } catch (err) { return jsonResponse({success: false, message: err.toString()}); }
}

function uploadFile(payload) {
  try {
    const folder = DriveApp.getFolderById(IMAGE_FOLDER_ID);
    const blob = Utilities.newBlob(Utilities.base64Decode(payload.file), payload.mimeType, payload.filename);
    const file = folder.createFile(blob);
    file.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW);
    return jsonResponse({success: true, url: 'https://lh3.googleusercontent.com/d/' + file.getId()});
  } catch (err) { return jsonResponse({success: false, message: err.toString()}); }
}

// --- INVENTORY FUNCTIONS ---
function readInventory(username) {
  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    let sheet = ss.getSheetByName(INVENTORY_SHEET_NAME);

    if (!sheet) {
      sheet = ss.insertSheet(INVENTORY_SHEET_NAME);
      sheet.appendRow(['date', 'ten sản phẩm', 'id sản phẩm', 'số lượng', 'trạng thái', 'còn lại', 'ten_dang_nhap']);
      return jsonResponse({success: true, data: []});
    }

    const lastRow = sheet.getLastRow();
    if (lastRow < 1) return jsonResponse({success: true, data: []});
    
    const values = sheet.getDataRange().getValues();
    const headers = values[0].map(normalizeHeader);
    const data = [];
    
    for (let i = 1; i < values.length; i++) {
      if (!values[i].join('').trim()) continue;
      let obj = {};
      headers.forEach((header, index) => { if (header) obj[header] = values[i][index]; });
      
      const storedUsername = obj['tendangnhap'] || obj['ten_dang_nhap'] || '';
      const normalizedStoredUsername = normalizeHeader(storedUsername);
      const normalizedRequestUsername = normalizeHeader(username);
      
      if (!username || storedUsername === username || normalizedStoredUsername === normalizedRequestUsername || String(storedUsername).trim().toLowerCase() === String(username).trim().toLowerCase()) {
        data.push(obj);
      }
    }
    
    return jsonResponse({success: true, data: data});
  } catch (err) { 
    return jsonResponse({success: false, message: err.toString()}); 
  }
}

function createInventory(payload) {
  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    let sheet = ss.getSheetByName(INVENTORY_SHEET_NAME);
    
    // Nếu sheet chưa tồn tại, tạo mới với headers (8 cột match sheet hiện tại)
    if (!sheet) {
      sheet = ss.insertSheet(INVENTORY_SHEET_NAME);
      sheet.appendRow(['date', 'ten sản phẩm', 'id sản phẩm', 'số lượng', 'trạng thái', 'còn lại', 'ten_dang_nhap']);
    }
    
    const rawHeaders = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    const headers = rawHeaders.map(normalizeHeader);

    // Normalize incoming payload keys
    const normalizedPayload = normalizeDataKeys(payload.data);

    // Build canonical header mapping
    const canonicalHeaders = headers.map(h => canonicalizeHeader(h));

    // Compute con_lai automatically: sum existing in/out for the same product id then apply this record
    const lastRow = sheet.getLastRow();
    const lastCol = sheet.getLastColumn();
    let existingRows = [];
    if (lastRow > 1) {
      existingRows = sheet.getRange(2, 1, lastRow - 1, lastCol).getValues();
    }

    // Find column indexes by canonical header
    const idIdx = canonicalHeaders.indexOf('id_san_pham');
    const inIdx = canonicalHeaders.indexOf('so_luong_nhap');
    const outIdx = canonicalHeaders.indexOf('so_luong_xuat');
    const soLuongIdx_Sheet = headers.indexOf('soluong');
    const trangThaiIdx_Sheet = headers.indexOf('trangthai');

    // Sum existing quantities for this product id
    const productId = normalizedPayload['id_san_pham'] || normalizedPayload['idsanpham'] || '';
    let totalIn = 0;
    let totalOut = 0;
    if (productId && existingRows.length > 0 && idIdx !== -1) {
      for (let r = 0; r < existingRows.length; r++) {
        const row = existingRows[r];
        const rowId = String(row[idIdx] || '').trim();
        if (rowId && rowId === String(productId)) {
          let vIn = 0;
          let vOut = 0;
          
          if (inIdx !== -1) vIn = parseFloat(row[inIdx]) || 0;
          if (outIdx !== -1) vOut = parseFloat(row[outIdx]) || 0;
          
          // Check generic columns if separate columns not found or if they are 0
          if (soLuongIdx_Sheet !== -1 && (vIn === 0 && vOut === 0)) {
            const qty = parseFloat(row[soLuongIdx_Sheet]) || 0;
            const status = String(row[trangThaiIdx_Sheet] || '').toLowerCase();
            if (status === 'xuất' || status.includes('xuat')) {
              vOut = qty;
            } else {
              vIn = qty;
            }
          }
          
          totalIn += vIn;
          totalOut += vOut;
        }
      }
    }

    const thisIn = parseFloat(normalizedPayload['so_luong_nhap']) || parseFloat(normalizedPayload['soluongnhap']) || 0;
    const thisOut = parseFloat(normalizedPayload['so_luong_xuat']) || parseFloat(normalizedPayload['soluongxuat']) || 0;
    const newRemaining = (totalIn + thisIn) - (totalOut + thisOut);
    // Only set con_lai if not provided or if calculation gives a value
    if (!normalizedPayload['con_lai'] && !normalizedPayload['conlai']) {
      normalizedPayload['con_lai'] = newRemaining;
    }

    // Helper to resolve a value from normalizedPayload using several key variants
    function resolvePayloadValue(canonKey, normHeader) {
      if (!normalizedPayload) return undefined;
      // 1) exact canonical form (e.g. 'so_luong_nhap')
      if (normalizedPayload[canonKey] !== undefined) return normalizedPayload[canonKey];
      // 2) canonical without underscores (e.g. 'soluongnhap')
      const canonCompact = String(canonKey || '').replace(/_/g, '');
      if (normalizedPayload[canonCompact] !== undefined) return normalizedPayload[canonCompact];
      // 3) normalized header as returned from sheet (e.g. 'soluong')
      if (normHeader && normalizedPayload[normHeader] !== undefined) return normalizedPayload[normHeader];
      // 4) try variants: without underscores on normHeader
      if (normHeader) {
        const normCompact = String(normHeader).replace(/[^a-z0-9]/g, '');
        if (normalizedPayload[normCompact] !== undefined) return normalizedPayload[normCompact];
      }
      return undefined;
    }

    const newRow = rawHeaders.map((h, i) => {
      const canon = canonicalHeaders[i];
      const normH = headers[i];
      
      const v = resolvePayloadValue(canon, normH);
      return v !== undefined ? v : '';
    });

    // Special handling: if sheet has generic 'số lượng' column, map incoming quantity into it
    const soLuongIdx = headers.indexOf('soluong');
    if (soLuongIdx !== -1) {
      const status = String(normalizedPayload['trangthai'] || normalizedPayload['trang_thai'] || '').toLowerCase();
      let qtyToStore = 0;
      if (status === 'xuất' || status.includes('xuat')) {
        qtyToStore = thisOut;
      } else {
        qtyToStore = thisIn;
      }
      newRow[soLuongIdx] = qtyToStore;
    }

    sheet.appendRow(newRow);

    // Build debug object mapping original headers to written values
    const written = {};
    rawHeaders.forEach((h, i) => { written[h] = newRow[i]; });
    return jsonResponse({success: true, row: written, computed_con_lai: normalizedPayload['con_lai']});
  } catch (err) { 
    return jsonResponse({success: false, message: err.toString()}); 
  }
}

function jsonResponse(obj) {
  return ContentService.createTextOutput(JSON.stringify(obj)).setMimeType(ContentService.MimeType.JSON);
}

function updateInventory(payload) {
  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const sheet = ss.getSheetByName(INVENTORY_SHEET_NAME);
    
    if (!sheet) throw new Error('Không tìm thấy sheet tồn kho');

    const values = sheet.getDataRange().getValues();
    const rawHeaders = values[0];
    const headers = rawHeaders.map(normalizeHeader);
    const dateIdx = headers.indexOf('date');
    const idIdx = headers.indexOf('idsanpham');
    
    if (dateIdx === -1 || idIdx === -1) throw new Error('Cột date hoặc id_san_pham không tồn tại');

    // Find the row to update by matching date and id_san_pham
    const targetDate = payload.data.date;
    const targetId = payload.data.id_san_pham;
    
    let foundRow = -1;
    for (let i = 1; i < values.length; i++) {
        const rowDate = String(values[i][dateIdx] || '').trim();
        const rowId = String(values[i][idIdx] || '').trim();
        
        if (rowDate === String(targetDate).trim() && rowId === String(targetId).trim()) {
            foundRow = i + 1;
            break;
        }
    }

    if (foundRow === -1) throw new Error('Không tìm thấy bản ghi để cập nhật');

    // Normalize payload data
    const normalizedPayload = normalizeDataKeys(payload.data);
    const canonicalHeaders = headers.map(h => canonicalizeHeader(h));

    // Update each column
    headers.forEach((h, index) => {
      const canon = canonicalHeaders[index];
      if (h) {
        let v = normalizedPayload[canon] || normalizedPayload[h];
        
        // Handle mapping for generic 'số lượng' column during edit
        if (h === 'soluong') {
          const status = String(normalizedPayload['trangthai'] || normalizedPayload['trang_thai'] || '').toLowerCase();
          if (status === 'xuất' || status.includes('xuat')) {
            v = normalizedPayload['so_luong_xuat'] || normalizedPayload['soluongxuat'] || v;
          } else {
            v = normalizedPayload['so_luong_nhap'] || normalizedPayload['soluongnhap'] || v;
          }
        }
        
        if (v !== undefined) {
          sheet.getRange(foundRow, index + 1).setValue(v);
        }
      }
    });

    return jsonResponse({success: true, message: 'Cập nhật tồn kho thành công'});
  } catch (err) { 
    return jsonResponse({success: false, message: err.toString()}); 
  }
}



function ensureColumnExists(sheet, columnName) {
  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0].map(normalizeHeader);
  console.log('Headers retrieved:', headers);

  if (headers.length === 0) {
    throw new Error('Sheet không có tiêu đề cột. Vui lòng kiểm tra cấu trúc sheet.');
  }

  const normalizedColumnName = normalizeHeader(columnName);
  console.log('Normalized column name:', normalizedColumnName);

  // Check for duplicates (log warning instead of throwing to prevent crashing the whole app)
  const duplicateCount = headers.filter(header => header === normalizedColumnName).length;
  if (duplicateCount > 1) {
    console.warn(`Sheet có nhiều cột trùng tên: ${columnName}. Hệ thống sẽ sử dụng cột đầu tiên.`);
  }

  if (headers.indexOf(normalizedColumnName) === -1) {
    const lastCol = sheet.getLastColumn();
    console.log(`Adding missing column: ${columnName} at position ${lastCol + 1}`);

    sheet.getRange(1, lastCol + 1).setValue(columnName);
    const lastRow = sheet.getLastRow();

    for (let i = 2; i <= lastRow; i++) {
      sheet.getRange(i, lastCol + 1).setValue('');
    }
  }
}
