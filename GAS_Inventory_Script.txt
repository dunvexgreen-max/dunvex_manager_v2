const DATA_FOLDER_ID = '1_LT4rzVui2E3BgfcwUSfMsUGQMN9NRTs';

const FILES = {
  NHAP: 'ton_kho_nhap.json',
  XUAT: 'ton_kho_xuat.json',
  TONG_HOP: 'ton_kho_tong_hop.json',
  ORDER_DETAIL: 'order_chi_tiet.json'
};

// --- SECURITY CONFIG ---
const RAW_SECRET = PropertiesService.getScriptProperties().getProperty('CRM_SECRET') || 'dv_secure_fallback_2024';
const CIPHER_KEY = Utilities.computeDigest(Utilities.DigestAlgorithm.MD5, RAW_SECRET);

function encryptData(text) {
  if (!text) return "";
  try {
    const blob = Utilities.newBlob(text.toString().trim()); 
    const encrypted = Utilities.encrypt(Utilities.CipherAlgorithm.AES_128, CIPHER_KEY, blob);
    return Utilities.base64Encode(encrypted);
  } catch (e) { return text; }
}

function decryptData(base64Text) {
  if (!base64Text || base64Text.length < 10) return base64Text;
  try {
    const decoded = Utilities.base64Decode(base64Text);
    const decrypted = Utilities.decrypt(Utilities.CipherAlgorithm.AES_128, CIPHER_KEY, decoded);
    return decrypted.getDataAsString();
  } catch (e) { return base64Text; }
}

function doPost(e) {
  let result;
  try {
    const contents = e.postData ? e.postData.contents : "";
    if (!contents) {
       return ContentService.createTextOutput(JSON.stringify({ success: false, message: 'D·ªØ li·ªáu POST tr·ªëng (Inventory Script)' })).setMimeType(ContentService.MimeType.JSON);
    }
    const data = JSON.parse(contents);
    const action = (data.action || "").toString().trim();

    switch (action) {
      case 'get_inventory_report':
        result = getInventoryReport(data.adminEmail);
        break;
      case 'save_inventory_entry':
        result = saveInventoryEntry(data, data.adminEmail);
        break;
      case 'sync_order_to_inventory':
        result = syncOrderToInventory(data.orderId, data.userEmail, data.adminEmail, data.status);
        break;
      case 'get_inventory_logs':
        result = getInventoryLogs(data.adminEmail);
        break;
      case 'delete_inventory_entry':
        result = deleteInventoryEntry(data.id, data.adminEmail);
        break;
      case 'update_inventory_entry':
        result = updateInventoryEntry(data, data.adminEmail);
        break;
      default:
        result = { success: false, message: 'H√†nh ƒë·ªông [' + action + '] kh√¥ng h·ª£p l·ªá t·∫°i Inventory Script' };
    }
  } catch (error) {
    result = { success: false, message: 'L·ªói Backend Inventory: ' + error.toString() };
  }
  return ContentService.createTextOutput(JSON.stringify(result)).setMimeType(ContentService.MimeType.JSON);
}

function getFile(filename) {
  const folder = DriveApp.getFolderById(DATA_FOLDER_ID);
  const files = folder.getFilesByName(filename);
  if (files.hasNext()) return files.next();
  return folder.createFile(filename, '[]', MimeType.PLAIN_TEXT);
}

function syncOrderToInventory(orderId, userEmail, adminEmail, status) {
  try {
    const finalizedStatuses = ['ƒê∆°n ch·ªët', 'Ho√†n th√†nh', 'ƒë∆°n ch·ªët', 'ho√†n th√†nh'];
    const isFinalized = finalizedStatuses.includes((status || "").toString().trim());

    const fileXuat = getFile(FILES.XUAT);
    let logsXuat = JSON.parse(fileXuat.getBlob().getDataAsString() || '[]');
    const prefix = "SYNC-" + orderId;

    // 1. Lu√¥n x√≥a c√°c b·∫£n ghi c≈© c·ªßa ƒë∆°n n√†y ƒë·ªÉ c·∫≠p nh·∫≠t m·ªõi (ho·∫∑c g·ª° b·ªè n·∫øu status kh√¥ng c√≤n l√† finalized)
    const initialCount = logsXuat.length;
    logsXuat = logsXuat.filter(l => !l.id || !l.id.startsWith(prefix));

    if (isFinalized) {
      const fileDetail = getFile(FILES.ORDER_DETAIL);
      const allDetails = JSON.parse(fileDetail.getBlob().getDataAsString() || '[]');
      const items = allDetails.filter(d => d.id_don_hang === orderId);

      if (items.length > 0) {
        items.forEach(item => {
          logsXuat.push({
            id: prefix + "-" + new Date().getTime() + "-" + Math.random().toString(36).substr(2, 5),
            productId: item.ma_san_pham || item.id_san_pham,
            productName: item.ten_san_pham,
            quantity: parseFloat(item.so_luong || 0),
            unit: item.don_vi_tinh || 'C√°i',
            date: new Date().toISOString(),
            user: encryptData(userEmail),
            ownedByAdmin: encryptData(adminEmail),
            note: "Xu·∫•t t·ª´ ƒë∆°n h√†ng: " + orderId
          });
        });
      }
    }

    fileXuat.setContent(JSON.stringify(logsXuat, null, 2));
    calculateStock(adminEmail); 

    return { 
      success: true, 
      message: isFinalized ? 'ƒê√£ c·∫≠p nh·∫≠t xu·∫•t kho theo ƒë∆°n h√†ng' : 'ƒê√£ g·ª° b·ªè xu·∫•t kho (ƒë∆°n h√†ng ch∆∞a ch·ªët)' 
    };
  } catch (e) {
    return { success: false, message: 'L·ªói sync: ' + e.toString() };
  }
}

function saveInventoryEntry(data, adminEmail) {
  try {
    const filename = data.type === 'NHAP' ? FILES.NHAP : FILES.XUAT;
    const file = getFile(filename);
    let logs = JSON.parse(file.getBlob().getDataAsString() || '[]');
    
    logs.push({
      id: "INV-" + new Date().getTime(),
      productId: data.productId,
      productName: data.productName,
      quantity: parseFloat(data.quantity || 0),
      unit: data.unit,
      date: new Date().toISOString(),
      user: encryptData(data.userEmail),
      ownedByAdmin: encryptData(adminEmail),
      note: data.note || ''
    });
    
    file.setContent(JSON.stringify(logs, null, 2));
    calculateStock(adminEmail);
    
    return { success: true, message: 'C·∫≠p nh·∫≠t kho th√†nh c√¥ng' };
  } catch (e) {
    return { success: false, message: 'L·ªói save: ' + e.toString() };
  }
}

function calculateStock(adminEmail) {
  if (!adminEmail) return { success: false, message: "Email Admin kh√¥ng t·ªìn t·∫°i" };

  try {
    const fileNhap = getFile(FILES.NHAP);
    const fileXuat = getFile(FILES.XUAT);
    const nhapData = JSON.parse(fileNhap.getBlob().getDataAsString() || '[]');
    const xuatData = JSON.parse(fileXuat.getBlob().getDataAsString() || '[]');
    
    const stockMap = {};

    // T√≠nh Nh·∫≠p
    nhapData.filter(i => decryptData(i.ownedByAdmin) === adminEmail).forEach(i => {
      if (!stockMap[i.productId]) stockMap[i.productId] = { id: i.productId, name: i.productName, unit: i.unit, in: 0, out: 0 };
      stockMap[i.productId].in += i.quantity;
    });

    // T√≠nh Xu·∫•t
    xuatData.filter(i => decryptData(i.ownedByAdmin) === adminEmail).forEach(i => {
      if (!stockMap[i.productId]) stockMap[i.productId] = { id: i.productId, name: i.productName, unit: i.unit, in: 0, out: 0 };
      stockMap[i.productId].out += i.quantity;
    });

    const encAdmin = encryptData(adminEmail);
    const finalStock = Object.values(stockMap).map(i => ({
      id: i.id, name: i.name, unit: i.unit, 
      tongNhap: i.in, tongXuat: i.out, tonKho: i.in - i.out,
      ownedByAdmin: encAdmin
    }));

    const fileTongHop = getFile(FILES.TONG_HOP);
    let allSummary = JSON.parse(fileTongHop.getBlob().getDataAsString() || '[]');
    
    allSummary = allSummary.filter(s => decryptData(s.ownedByAdmin) !== adminEmail);
    allSummary.push(...finalStock);
    
    fileTongHop.setContent(JSON.stringify(allSummary, null, 2));
    
    // G·ª¨I EMAIL C·∫¢NH B√ÅO
    checkAndSendEmailAlert(finalStock, adminEmail);
    
    return { success: true, data: finalStock };
  } catch (e) {
    return { success: false, message: 'L·ªói calculate: ' + e.toString() };
  }
}

function getInventoryLogs(adminEmail) {
  try {
    const fileNhap = getFile(FILES.NHAP);
    const fileXuat = getFile(FILES.XUAT);
    const nhapData = JSON.parse(fileNhap.getBlob().getDataAsString() || '[]');
    const xuatData = JSON.parse(fileXuat.getBlob().getDataAsString() || '[]');

    const logs = [];
    
    nhapData.filter(l => decryptData(l.ownedByAdmin) === adminEmail).forEach(l => {
      logs.push({ ...l, type: 'NHAP', user: decryptData(l.user) });
    });
    
    xuatData.filter(l => decryptData(l.ownedByAdmin) === adminEmail).forEach(l => {
      logs.push({ ...l, type: 'XUAT', user: decryptData(l.user) });
    });

    // S·∫Øp x·∫øp theo ng√†y m·ªõi nh·∫•t l√™n ƒë·∫ßu
    logs.sort((a, b) => new Date(b.date) - new Date(a.date));

    return { success: true, data: logs };
  } catch (e) {
    return { success: false, message: 'L·ªói getLogs: ' + e.toString() };
  }
}

function deleteInventoryEntry(id, adminEmail) {
  try {
    let found = false;

    // Ki·ªÉm tra v√† x√≥a trong Nh·∫≠p
    const fileNhap = getFile(FILES.NHAP);
    let nhapLogs = JSON.parse(fileNhap.getBlob().getDataAsString() || '[]');
    const newNhap = nhapLogs.filter(l => {
      if (l.id === id && decryptData(l.ownedByAdmin) === adminEmail) {
        found = true;
        return false;
      }
      return true;
    });
    if (found) fileNhap.setContent(JSON.stringify(newNhap, null, 2));

    // N·∫øu ch∆∞a th·∫•y th√¨ x√≥a trong Xu·∫•t
    if (!found) {
      const fileXuat = getFile(FILES.XUAT);
      let xuatLogs = JSON.parse(fileXuat.getBlob().getDataAsString() || '[]');
      const newXuat = xuatLogs.filter(l => {
        if (l.id === id && decryptData(l.ownedByAdmin) === adminEmail) {
          found = true;
          return false;
        }
        return true;
      });
      if (found) fileXuat.setContent(JSON.stringify(newXuat, null, 2));
    }

    if (found) {
      calculateStock(adminEmail);
      return { success: true, message: 'ƒê√£ x√≥a b·∫£n ghi kho' };
    }
    return { success: false, message: 'Kh√¥ng t√¨m th·∫•y b·∫£n ghi ho·∫∑c kh√¥ng c√≥ quy·ªÅn' };
  } catch (e) {
    return { success: false, message: 'L·ªói x√≥a: ' + e.toString() };
  }
}

function updateInventoryEntry(data, adminEmail) {
  try {
    const id = data.id;
    let found = false;

    // Th·ª≠ c·∫≠p nh·∫≠t trong Nh·∫≠p
    const fileNhap = getFile(FILES.NHAP);
    let nhapLogs = JSON.parse(fileNhap.getBlob().getDataAsString() || '[]');
    nhapLogs = nhapLogs.map(l => {
      if (l.id === id && decryptData(l.ownedByAdmin) === adminEmail) {
        found = true;
        return {
          ...l,
          productId: data.productId || l.productId,
          productName: data.productName || l.productName,
          quantity: parseFloat(data.quantity || l.quantity),
          unit: data.unit || l.unit,
          note: data.note || l.note
        };
      }
      return l;
    });
    if (found) fileNhap.setContent(JSON.stringify(nhapLogs, null, 2));

    // Th·ª≠ c·∫≠p nh·∫≠t trong Xu·∫•t
    if (!found) {
      const fileXuat = getFile(FILES.XUAT);
      let xuatLogs = JSON.parse(fileXuat.getBlob().getDataAsString() || '[]');
      xuatLogs = xuatLogs.map(l => {
        if (l.id === id && decryptData(l.ownedByAdmin) === adminEmail) {
          found = true;
          return {
            ...l,
            productId: data.productId || l.productId,
            productName: data.productName || l.productName,
            quantity: parseFloat(data.quantity || l.quantity),
            unit: data.unit || l.unit,
            note: data.note || l.note
          };
        }
        return l;
      });
      if (found) fileXuat.setContent(JSON.stringify(xuatLogs, null, 2));
    }

    if (found) {
      calculateStock(adminEmail);
      return { success: true, message: 'C·∫≠p nh·∫≠t b·∫£n ghi th√†nh c√¥ng' };
    }
    return { success: false, message: 'Kh√¥ng t√¨m th·∫•y b·∫£n ghi' };
  } catch (e) {
    return { success: false, message: 'L·ªói c·∫≠p nh·∫≠t: ' + e.toString() };
  }
}

function getInventoryReport(adminEmail) {
  try {
    const file = getFile(FILES.TONG_HOP);
    const allData = JSON.parse(file.getBlob().getDataAsString() || '[]');
    
    const filtered = allData.filter(d => decryptData(d.ownedByAdmin) === adminEmail).map(d => {
      const copy = Object.assign({}, d);
      copy.ownedByAdmin = adminEmail;
      return copy;
    });
    return { success: true, data: filtered };
  } catch (e) {
    return { success: false, message: 'L·ªói getReport: ' + e.toString() };
  }
}

function checkAndSendEmailAlert(stockList, adminEmail) {
  try {
    if (!adminEmail || !adminEmail.includes('@')) return;

    const lowStockItems = stockList.filter(item => item.tonKho < 10);
    if (lowStockItems.length === 0) return;

    let htmlBody = `
      <div style="font-family: Arial, sans-serif; padding: 20px; border: 1px solid #eee; border-radius: 10px;">
        <h2 style="color: #ef4444;">üö® C·∫¢NH B√ÅO T·ªíN KHO TH·∫§P</h2>
        <p>H·ªá th·ªëng Dunvex ph√°t hi·ªán doanh nghi·ªáp c·ªßa b·∫°n ƒëang s·∫Øp h·∫øt c√°c s·∫£n ph·∫©m sau:</p>
        <table border="1" style="border-collapse: collapse; width: 100%; text-align: left;">
          <tr style="background: #f8fafc;">
            <th style="padding: 10px;">S·∫£n ph·∫©m</th>
            <th style="padding: 10px;">M√£ s·ªë</th>
            <th style="padding: 10px;">T·ªìn th·ª±c t·∫ø</th>
          </tr>
    `;

    lowStockItems.forEach(item => {
      htmlBody += `
        <tr>
          <td style="padding: 10px;">${item.name}</td>
          <td style="padding: 10px;">${item.id}</td>
          <td style="padding: 10px; color: red; font-weight: bold;">${item.tonKho} ${item.unit}</td>
        </tr>
      `;
    });

    htmlBody += `
        </table>
        <p style="margin-top: 20px;">Vui l√≤ng ki·ªÉm tra v√† nh·∫≠p h√†ng k·ªãp th·ªùi cho doanh nghi·ªáp c·ªßa b·∫°n.</p>
      </div>
    `;

    MailApp.sendEmail({
      to: adminEmail,
      subject: "üö® [Dunvex Inventory] C·∫£nh b√°o s·∫£n ph·∫©m s·∫Øp h·∫øt h√†ng",
      htmlBody: htmlBody
    });
  } catch (e) {
    console.error("L·ªói g·ª≠i mail: " + e.toString());
  }
}
