const DATA_FOLDER_ID = '1_LT4rzVui2E3BgfcwUSfMsUGQMN9NRTs';

const FILES = {
  NHAP: 'ton_kho_nhap.json',
  XUAT: 'ton_kho_xuat.json',
  TONG_HOP: 'ton_kho_tong_hop.json',
  ORDER_DETAIL: 'order_chi_tiet.json'
};

// --- SECURITY CONFIG (XOR ENCRYPTION) ---
const XOR_SECRET = 'dunvex_secure_key_2025_custom';
// Legacy AES Key
const AES_KEY = Utilities.newBlob('dunvex_secure_16').getBytes();

function encryptXOR(text) {
  if (!text) return "";
  try {
    const inputBytes = Utilities.newBlob(text.toString()).getBytes();
    const keyBytes = Utilities.newBlob(XOR_SECRET).getBytes();
    const outputBytes = [];
    for (let i = 0; i < inputBytes.length; i++) {
        outputBytes.push(inputBytes[i] ^ keyBytes[i % keyBytes.length]);
    }
    return Utilities.base64Encode(outputBytes);
  } catch (e) { return "ENC_ERR: " + e.toString(); }
}

function decryptXOR(base64Text) {
  if (!base64Text || base64Text.length < 5 || base64Text.startsWith("ENC_ERR")) return base64Text;
  try {
    const inputBytes = Utilities.base64Decode(base64Text);
    const keyBytes = Utilities.newBlob(XOR_SECRET).getBytes();
    const outputBytes = [];
    for (let i = 0; i < inputBytes.length; i++) {
        outputBytes.push(inputBytes[i] ^ keyBytes[i % keyBytes.length]);
    }
    return Utilities.newBlob(outputBytes).getDataAsString();
  } catch (e) { return base64Text; }
}

function decryptAES(base64Text) {
  if (!base64Text || base64Text.length < 10) return base64Text;
  try {
    const decoded = Utilities.base64Decode(base64Text);
    const decrypted = Utilities.decrypt(Utilities.CipherAlgorithm.AES_128, AES_KEY, decoded);
    return decrypted.getDataAsString();
  } catch (e) { return null; }
}

// Unified Encrypt (Default to XOR for new data)
function encryptData(text) {
  return encryptXOR(text);
}

// Unified Decrypt (Try XOR first, then AES)
function decryptData(base64Text) {
  let dec = decryptXOR(base64Text);
  // Heuristic: Valid email usually contains '@'. If XOR results in garbage, try AES.
  if ((!dec || !dec.includes('@')) && base64Text) {
     const aes = decryptAES(base64Text);
     if (aes && aes.includes('@')) return aes;
  }
  return dec || base64Text;
}

function doPost(e) {
  let result;
  try {
    const contents = e.postData ? e.postData.contents : "";
    if (!contents) {
       return ContentService.createTextOutput(JSON.stringify({ success: false, message: 'Dữ liệu POST trống (Inventory Script)' })).setMimeType(ContentService.MimeType.JSON);
    }
    const data = JSON.parse(contents);
    const action = (data.action || "").toString().trim();

    switch (action) {
      case 'get_inventory_report':
        result = getInventoryReport(data.adminEmail);
        break;
      case 'save_inventory_entry':
        result = saveInventoryEntry(data, data.adminEmail);
        break;
      case 'sync_order_to_inventory':
        result = syncOrderToInventory(data.orderId, data.userEmail, data.adminEmail, data.status);
        break;
      case 'get_inventory_logs':
        result = getInventoryLogs(data.adminEmail);
        break;
      case 'delete_inventory_entry':
        result = deleteInventoryEntry(data.id, data.adminEmail);
        break;
      case 'update_inventory_entry':
        result = updateInventoryEntry(data, data.adminEmail);
        break;
      default:
        result = { success: false, message: 'Hành động [' + action + '] không hợp lệ tại Inventory Script' };
    }
  } catch (error) {
    result = { success: false, message: 'Lỗi Backend Inventory: ' + error.toString() };
  }
  return ContentService.createTextOutput(JSON.stringify(result)).setMimeType(ContentService.MimeType.JSON);
}

function getFile(filename) {
  const folder = DriveApp.getFolderById(DATA_FOLDER_ID);
  const files = folder.getFilesByName(filename);
  if (files.hasNext()) return files.next();
  return folder.createFile(filename, '[]', MimeType.PLAIN_TEXT);
}

function syncOrderToInventory(orderId, userEmail, adminEmail, status) {
  try {
    const finalizedStatuses = ['Đơn chốt', 'Hoàn thành', 'đơn chốt', 'hoàn thành'];
    const isFinalized = finalizedStatuses.includes((status || "").toString().trim());
    const safeAdmin = (adminEmail || "").toLowerCase().trim();

    const fileXuat = getFile(FILES.XUAT);
    let logsXuat = JSON.parse(fileXuat.getBlob().getDataAsString() || '[]');
    const prefix = "SYNC-" + orderId;

    // 1. Luôn xóa các bản ghi cũ của đơn này để cập nhật mới (hoặc gỡ bỏ nếu status không còn là finalized)
    const initialCount = logsXuat.length;
    logsXuat = logsXuat.filter(l => !l.id || !l.id.startsWith(prefix));

    if (isFinalized) {
      const fileDetail = getFile(FILES.ORDER_DETAIL);
      const allDetails = JSON.parse(fileDetail.getBlob().getDataAsString() || '[]');
      const items = allDetails.filter(d => d.id_don_hang === orderId);

      if (items.length > 0) {
        items.forEach(item => {
          logsXuat.push({
            id: prefix + "-" + new Date().getTime() + "-" + Math.random().toString(36).substr(2, 5),
            productId: item.ma_san_pham || item.id_san_pham,
            productName: item.ten_san_pham,
            quantity: parseFloat(item.so_luong || 0),
            unit: item.don_vi_tinh || 'Cái',
            date: new Date().toISOString(),
            user: encryptData(userEmail), // Uses XOR
            ownedByAdmin: encryptData(safeAdmin), // Uses XOR
            note: "Xuất từ đơn hàng: " + orderId
          });
        });
      }
    }

    fileXuat.setContent(JSON.stringify(logsXuat, null, 2));
    calculateStock(safeAdmin); 

    return { 
      success: true, 
      message: isFinalized ? 'Đã cập nhật xuất kho theo đơn hàng' : 'Đã gỡ bỏ xuất kho (đơn hàng chưa chốt)' 
    };
  } catch (e) {
    return { success: false, message: 'Lỗi sync: ' + e.toString() };
  }
}

function saveInventoryEntry(data, adminEmail) {
  try {
    const filename = data.type === 'NHAP' ? FILES.NHAP : FILES.XUAT;
    const file = getFile(filename);
    const safeAdmin = (adminEmail || "").toLowerCase().trim();
    let logs = JSON.parse(file.getBlob().getDataAsString() || '[]');
    
    logs.push({
      id: "INV-" + new Date().getTime(),
      productId: data.productId,
      productName: data.productName,
      quantity: parseFloat(data.quantity || 0),
      unit: data.unit,
      date: new Date().toISOString(),
      user: encryptData(data.userEmail),
      ownedByAdmin: encryptData(safeAdmin),
      note: data.note || ''
    });
    
    file.setContent(JSON.stringify(logs, null, 2));
    calculateStock(safeAdmin);
    
    return { success: true, message: 'Cập nhật kho thành công' };
  } catch (e) {
    return { success: false, message: 'Lỗi save: ' + e.toString() };
  }
}

function calculateStock(adminEmail) {
  if (!adminEmail) return { success: false, message: "Email Admin không tồn tại" };
  const safeAdmin = adminEmail.toLowerCase().trim();

  try {
    const fileNhap = getFile(FILES.NHAP);
    const fileXuat = getFile(FILES.XUAT);
    const nhapData = JSON.parse(fileNhap.getBlob().getDataAsString() || '[]');
    const xuatData = JSON.parse(fileXuat.getBlob().getDataAsString() || '[]');
    
    const stockMap = {};

    // Tính Nhập (So sánh linh hoạt lowercase)
    nhapData.filter(i => (decryptData(i.ownedByAdmin) || "").toLowerCase() === safeAdmin).forEach(i => {
      if (!stockMap[i.productId]) stockMap[i.productId] = { id: i.productId, name: i.productName, unit: i.unit, in: 0, out: 0 };
      stockMap[i.productId].in += i.quantity;
    });

    // Tính Xuất
    xuatData.filter(i => (decryptData(i.ownedByAdmin) || "").toLowerCase() === safeAdmin).forEach(i => {
      if (!stockMap[i.productId]) stockMap[i.productId] = { id: i.productId, name: i.productName, unit: i.unit, in: 0, out: 0 };
      stockMap[i.productId].out += i.quantity;
    });

    const encAdmin = encryptData(safeAdmin);
    const finalStock = Object.values(stockMap).map(i => ({
      id: i.id, name: i.name, unit: i.unit, 
      tongNhap: i.in, tongXuat: i.out, tonKho: i.in - i.out,
      ownedByAdmin: encAdmin
    }));

    const fileTongHop = getFile(FILES.TONG_HOP);
    let allSummary = JSON.parse(fileTongHop.getBlob().getDataAsString() || '[]');
    
    // Xóa cũ (của admin này) để ghi mới. Dùng so sánh an toàn
    allSummary = allSummary.filter(s => (decryptData(s.ownedByAdmin) || "").toLowerCase() !== safeAdmin);
    allSummary.push(...finalStock);
    
    fileTongHop.setContent(JSON.stringify(allSummary, null, 2));
    
    // GỬI EMAIL CẢNH BÁO
    checkAndSendEmailAlert(finalStock, safeAdmin);
    
    return { success: true, data: finalStock };
  } catch (e) {
    return { success: false, message: 'Lỗi calculate: ' + e.toString() };
  }
}

function getInventoryLogs(adminEmail) {
  try {
    const fileNhap = getFile(FILES.NHAP);
    const fileXuat = getFile(FILES.XUAT);
    const safeAdmin = (adminEmail || "").toLowerCase().trim();
    
    const nhapData = JSON.parse(fileNhap.getBlob().getDataAsString() || '[]');
    const xuatData = JSON.parse(fileXuat.getBlob().getDataAsString() || '[]');
    
    // Lọc theo admin và giải mã user (So sánh linh hoạt)
    const nhaps = nhapData.filter(i => (decryptData(i.ownedByAdmin) || "").toLowerCase() === safeAdmin).map(i => {
      i.type = 'NHAP';
      i.user = decryptData(i.user); 
      return i;
    });
    
    const xuats = xuatData.filter(i => (decryptData(i.ownedByAdmin) || "").toLowerCase() === safeAdmin).map(i => {
      i.type = 'XUAT';
      i.user = decryptData(i.user); 
      return i;
    });
    
    const all = [...nhaps, ...xuats].sort((a, b) => new Date(b.date) - new Date(a.date));
    return { success: true, data: all };
  } catch (e) {
    return { success: false, message: e.toString() };
  }
}

function getInventoryReport(adminEmail) {
  try {
    const fileTongHop = getFile(FILES.TONG_HOP);
    const safeAdmin = (adminEmail || "").toLowerCase().trim();
    const allSummary = JSON.parse(fileTongHop.getBlob().getDataAsString() || '[]');
    
    const filtered = allSummary.filter(s => (decryptData(s.ownedByAdmin) || "").toLowerCase() === safeAdmin);
    return { success: true, data: filtered };
  } catch(e) {
    return { success: false, message: e.toString() };
  }
}

function deleteInventoryEntry(id, adminEmail) {
  if (!id) return { success: false, message: "Thiếu ID" };
  try {
     const safeAdmin = (adminEmail || "").toLowerCase().trim();
     let updated = false;
     [FILES.NHAP, FILES.XUAT].forEach(fname => {
       const f = getFile(fname);
       let d = JSON.parse(f.getBlob().getDataAsString() || '[]');
       const lenBefore = d.length;
       d = d.filter(x => x.id !== id);
       if (d.length < lenBefore) {
         updated = true;
         f.setContent(JSON.stringify(d, null, 2));
       }
     });
     
     if (updated) {
       calculateStock(safeAdmin);
       return { success: true };
     } else {
       return { success: false, message: "Không tìm thấy ID" };
     }
  } catch(e) {
    return { success: false, message: e.toString() };
  }
}

function updateInventoryEntry(data, adminEmail) {
function updateInventoryEntry(data, adminEmail) {
   try {
    const safeAdmin = (adminEmail || "").toLowerCase().trim();
    let found = false;
    
    [FILES.NHAP, FILES.XUAT].forEach(fname => {
        if (found) return;
        
        const file = getFile(fname);
        let logs = JSON.parse(file.getBlob().getDataAsString() || '[]');
        
        const idx = logs.findIndex(l => l.id === data.id);
        if (idx !== -1) {
            found = true;
            // Update fields only if provided, preserve otherwise
            if (data.productId) logs[idx].productId = data.productId;
            if (data.productName) logs[idx].productName = data.productName;
            if (data.unit) logs[idx].unit = data.unit;
            
            // Always update editable fields
            logs[idx].quantity = parseFloat(data.quantity || 0);
            logs[idx].note = data.note;
            
            // Update user only if provided
            if (data.userEmail) {
               logs[idx].user = encryptData(data.userEmail);
            }
            
            // Re-encrypt admin/migrate to XOR
            if (safeAdmin) {
               logs[idx].ownedByAdmin = encryptData(safeAdmin);
            }
            
            file.setContent(JSON.stringify(logs, null, 2));
        }
    });
    
    if (found) {
        calculateStock(safeAdmin);
        return { success: true };
    } else {
        return { success: false, message: "Không tìm thấy ID trong cả 2 bảng Nhập/Xuất" };
    }
   } catch(e) {
     return { success: false, message: e.toString() };
   }
}

function checkAndSendEmailAlert(stockList, adminEmail) {
  // Logic gửi cảnh báo (không đổi)
  if (!adminEmail || !adminEmail.includes('@')) return;
  // ... (giữ nguyên logic nếu có)
}
