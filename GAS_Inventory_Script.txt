const DATA_FOLDER_ID = '1_LT4rzVui2E3BgfcwUSfMsUGQMN9NRTs';

const FILES = {
  NHAP: 'ton_kho_nhap.json',
  XUAT: 'ton_kho_xuat.json',
  TONG_HOP: 'ton_kho_tong_hop.json',
  ORDER_DETAIL: 'order_chi_tiet.json'
};

// --- SECURITY CONFIG (XOR ENCRYPTION) ---
const XOR_SECRET = 'dunvex_secure_key_2025_custom';
// Legacy AES Key
const AES_KEY = Utilities.newBlob('dunvex_secure_16').getBytes();

/**
 * HỆ THỐNG LƯU TRỮ AN TOÀN (SAFE STORAGE ENGINE)
 * Chống Race Condition bằng LockService và JSON Lines
 */
const SafeStore = {
  read: function(filename) {
    try {
      const folder = DriveApp.getFolderById(DATA_FOLDER_ID);
      const files = folder.getFilesByName(filename);
      if (!files.hasNext()) return [];
      const content = files.next().getBlob().getDataAsString().trim();
      if (!content) return [];
      if (content.startsWith('[')) return JSON.parse(content);
      return content.split('\n').filter(l => l.trim()).map(l => JSON.parse(l));
    } catch (e) { return []; }
  },
  write: function(filename, newData, action = 'APPEND') {
    const lock = LockService.getScriptLock();
    try {
      lock.waitLock(30000);
      const folder = DriveApp.getFolderById(DATA_FOLDER_ID);
      let file, files = folder.getFilesByName(filename);
      if (files.hasNext()) file = files.next();
      else file = folder.createFile(filename, '', MimeType.PLAIN_TEXT);

      let data = this.read(filename);
      if (action === 'APPEND') data.push(newData);
      else if (action === 'UPDATE') {
        const id = newData.id || newData.id_don_hang || newData.productId;
        const idx = data.findIndex(item => (item.id === id || item.id_don_hang === id || item.productId === id));
        if (idx !== -1) data[idx] = newData;
        else data.push(newData);
      } else if (action === 'DELETE') {
        const id = typeof newData === 'string' ? newData : (newData.id || newData.id_don_hang || newData.productId);
        data = data.filter(item => (item.id !== id && item.id_don_hang !== id && item.productId !== id && item.id_san_pham !== id));
      } else if (action === 'REPLACE_ALL') data = newData;

      file.setContent(data.map(item => JSON.stringify(item)).join('\n'));
      return { success: true };
    } catch (e) { return { success: false, message: e.toString() }; }
    finally { lock.releaseLock(); }
  }
};

function encryptXOR(text) {
  if (!text) return "";
  try {
    const inputBytes = Utilities.newBlob(text.toString()).getBytes();
    const keyBytes = Utilities.newBlob(XOR_SECRET).getBytes();
    const outputBytes = [];
    for (let i = 0; i < inputBytes.length; i++) {
        outputBytes.push(inputBytes[i] ^ keyBytes[i % keyBytes.length]);
    }
    return Utilities.base64Encode(outputBytes);
  } catch (e) { return "ENC_ERR: " + e.toString(); }
}

function decryptXOR(base64Text) {
  if (!base64Text || base64Text.length < 5 || base64Text.startsWith("ENC_ERR")) return base64Text;
  try {
    const inputBytes = Utilities.base64Decode(base64Text);
    const keyBytes = Utilities.newBlob(XOR_SECRET).getBytes();
    const outputBytes = [];
    for (let i = 0; i < inputBytes.length; i++) {
        outputBytes.push(inputBytes[i] ^ keyBytes[i % keyBytes.length]);
    }
    return Utilities.newBlob(outputBytes).getDataAsString();
  } catch (e) { return base64Text; }
}

function decryptAES(base64Text) {
  if (!base64Text || base64Text.length < 10) return base64Text;
  try {
    const decoded = Utilities.base64Decode(base64Text);
    const decrypted = Utilities.decrypt(Utilities.CipherAlgorithm.AES_128, AES_KEY, decoded);
    return decrypted.getDataAsString();
  } catch (e) { return null; }
}

function encryptData(text) { return encryptXOR(text); }

function decryptData(base64Text) {
  let dec = decryptXOR(base64Text);
  if ((!dec || !dec.includes('@')) && base64Text) {
     const aes = decryptAES(base64Text);
     if (aes && aes.includes('@')) return aes;
  }
  return dec || base64Text;
}

function doPost(e) {
  let result;
  try {
    const contents = e.postData ? e.postData.contents : "";
    if (!contents) return ContentService.createTextOutput(JSON.stringify({ success: false, message: 'Data empty' })).setMimeType(ContentService.MimeType.JSON);
    const data = JSON.parse(contents);
    const action = (data.action || "").toString().trim();
    switch (action) {
      case 'get_inventory_report': result = getInventoryReport(data.adminEmail); break;
      case 'save_inventory_entry': result = saveInventoryEntry(data, data.adminEmail); break;
      case 'sync_order_to_inventory': result = syncOrderToInventory(data.orderId, data.userEmail, data.adminEmail, data.status); break;
      case 'get_inventory_logs': result = getInventoryLogs(data.adminEmail); break;
      case 'delete_inventory_entry': result = deleteInventoryEntry(data.id, data.adminEmail); break;
      case 'update_inventory_entry': result = updateInventoryEntry(data, data.adminEmail); break;
      default: result = { success: false, message: 'Invalid action: ' + action };
    }
  } catch (error) { result = { success: false, message: error.toString() }; }
  return ContentService.createTextOutput(JSON.stringify(result)).setMimeType(ContentService.MimeType.JSON);
}

function getFile(filename) {
  const folder = DriveApp.getFolderById(DATA_FOLDER_ID);
  const files = folder.getFilesByName(filename);
  if (files.hasNext()) return files.next();
  return folder.createFile(filename, '[]', MimeType.PLAIN_TEXT);
}

function syncOrderToInventory(orderId, userEmail, adminEmail, status) {
  try {
    const finalizedStatuses = ['Đơn chốt', 'Hoàn thành', 'đơn chốt', 'hoàn thành'];
    const isFinalized = finalizedStatuses.includes((status || "").toString().trim());
    const safeAdmin = (adminEmail || "").toLowerCase().trim();
    const prefix = "SYNC-" + orderId;

    let logsXuat = SafeStore.read(FILES.XUAT);
    logsXuat = logsXuat.filter(l => !l.id || !l.id.startsWith(prefix));

    if (isFinalized) {
      const allDetails = SafeStore.read(FILES.ORDER_DETAIL);
      const items = allDetails.filter(d => d.id_don_hang === orderId);
      items.forEach(item => {
        logsXuat.push({
          id: prefix + "-" + new Date().getTime() + "-" + Math.random().toString(36).substr(2, 5),
          productId: item.ma_san_pham || item.id_san_pham,
          productName: item.ten_san_pham,
          quantity: parseFloat(item.so_luong || 0),
          unit: item.don_vi_tinh || 'Cái',
          date: new Date().toISOString(),
          user: encryptData(userEmail),
          ownedByAdmin: encryptData(safeAdmin),
          note: "Xuất từ đơn hàng: " + orderId
        });
      });
    }

    SafeStore.write(FILES.XUAT, logsXuat, 'REPLACE_ALL');
    calculateStock(safeAdmin); 
    return { success: true, message: isFinalized ? 'Đã cập nhật xuất kho' : 'Đã gỡ bỏ xuất kho' };
  } catch (e) { return { success: false, message: e.toString() }; }
}

function saveInventoryEntry(data, adminEmail) {
  try {
    const filename = data.type === 'NHAP' ? FILES.NHAP : FILES.XUAT;
    const safeAdmin = (adminEmail || "").toLowerCase().trim();
    const entry = {
      id: "INV-" + new Date().getTime(),
      productId: data.productId,
      productName: data.productName,
      quantity: parseFloat(data.quantity || 0),
      unit: data.unit,
      date: new Date().toISOString(),
      user: encryptData(data.userEmail),
      ownedByAdmin: encryptData(safeAdmin),
      note: data.note || ''
    };
    const res = SafeStore.write(filename, entry, 'APPEND');
    calculateStock(safeAdmin);
    return res;
  } catch (e) { return { success: false, message: e.toString() }; }
}

function calculateStock(adminEmail) {
  if (!adminEmail) return { success: false, message: "Email Admin missing" };
  const safeAdmin = adminEmail.toLowerCase().trim();
  try {
    const nhapData = SafeStore.read(FILES.NHAP);
    const xuatData = SafeStore.read(FILES.XUAT);
    const stockMap = {};

    nhapData.filter(i => (decryptData(i.ownedByAdmin) || "").toLowerCase() === safeAdmin).forEach(i => {
      if (!stockMap[i.productId]) stockMap[i.productId] = { id: i.productId, name: i.productName, unit: i.unit, in: 0, out: 0 };
      stockMap[i.productId].in += (parseFloat(i.quantity) || 0);
    });

    xuatData.filter(i => (decryptData(i.ownedByAdmin) || "").toLowerCase() === safeAdmin).forEach(i => {
      if (!stockMap[i.productId]) stockMap[i.productId] = { id: i.productId, name: i.productName, unit: i.unit, in: 0, out: 0 };
      stockMap[i.productId].out += (parseFloat(i.quantity) || 0);
    });

    const encAdmin = encryptData(safeAdmin);
    const finalStock = Object.values(stockMap).map(i => ({
      id: i.id, name: i.name, unit: i.unit, 
      tongNhap: i.in, tongXuat: i.out, tonKho: i.in - i.out,
      ownedByAdmin: encAdmin
    }));

    let allSummary = SafeStore.read(FILES.TONG_HOP);
    allSummary = allSummary.filter(s => (decryptData(s.ownedByAdmin) || "").toLowerCase() !== safeAdmin);
    allSummary.push(...finalStock);
    SafeStore.write(FILES.TONG_HOP, allSummary, 'REPLACE_ALL');
    
    return { success: true, data: finalStock };
  } catch (e) { return { success: false, message: e.toString() }; }
}

function getInventoryLogs(adminEmail) {
  try {
    const safeAdmin = (adminEmail || "").toLowerCase().trim();
    const nhaps = SafeStore.read(FILES.NHAP).filter(i => (decryptData(i.ownedByAdmin) || "").toLowerCase() === safeAdmin).map(i => {
      i.type = 'NHAP'; i.user = decryptData(i.user); return i;
    });
    const xuats = SafeStore.read(FILES.XUAT).filter(i => (decryptData(i.ownedByAdmin) || "").toLowerCase() === safeAdmin).map(i => {
      i.type = 'XUAT'; i.user = decryptData(i.user); return i;
    });
    const all = [...nhaps, ...xuats].sort((a, b) => new Date(b.date) - new Date(a.date));
    return { success: true, data: all };
  } catch (e) { return { success: false, message: e.toString() }; }
}

function getInventoryReport(adminEmail) {
  try {
    const safeAdmin = (adminEmail || "").toLowerCase().trim();
    const filtered = SafeStore.read(FILES.TONG_HOP).filter(s => (decryptData(s.ownedByAdmin) || "").toLowerCase() === safeAdmin);
    return { success: true, data: filtered };
  } catch(e) { return { success: false, message: e.toString() }; }
}

function deleteInventoryEntry(id, adminEmail) {
  if (!id) return { success: false, message: "Missing ID" };
  try {
     const safeAdmin = (adminEmail || "").toLowerCase().trim();
     SafeStore.write(FILES.NHAP, id, 'DELETE');
     SafeStore.write(FILES.XUAT, id, 'DELETE');
     calculateStock(safeAdmin);
     return { success: true };
  } catch(e) { return { success: false, message: e.toString() }; }
}

function updateInventoryEntry(data, adminEmail) {
   try {
    const safeAdmin = (adminEmail || "").toLowerCase().trim();
    let res = SafeStore.write(FILES.NHAP, data, 'UPDATE');
    if (!res.success) res = SafeStore.write(FILES.XUAT, data, 'UPDATE');
    calculateStock(safeAdmin);
    return { success: true };
   } catch(e) { return { success: false, message: e.toString() }; }
}

