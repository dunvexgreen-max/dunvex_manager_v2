/**
 * HƯỚNG DẪN:
 * 1. Mở Google Sheet của bạn.
 * 2. Vào Tiện ích mở rộng -> Apps Script.
 * 3. Dán mã này vào (thay thế mã cũ nếu có).
 * 4. Thay đổi SHEET_ID ở dòng dưới đây bằng ID Sheet của bạn.
 * 5. Nhấn 'Triển khai' -> 'Lưu trữ mới' -> 'Web App'.
 * 6. Chọn 'Anyone' (Bất kỳ ai) có quyền truy cập.
 * 7. Copy URL nhận được và dán vào file len-don.html.
 */

const SHEET_ID = '1RKbxHqK_f4upstxQ1a0H0H7VF6Ut_eqyoNpwdozdEKI';
// Map category -> sheet name
const CATEGORY_SHEETS = {
  'duraflex': 'don_hang_duraflex',
  'weber': 'don_hang_weber',
  'pima': 'don_hang_pima'
};
const COUNTER_SHEET_NAME = 'order_counter';

// Headers expected in each sheet (match the sheets you created)
const SHEET_HEADERS = {
  'don_hang_duraflex': [
    'Thời gian','Mã Đơn','Loại SP','Khách Hàng','Phân Loại KH',
    'Sản Phẩm','Đơn Giá','Số Lượng','Thành Tiền','số kiện','số tiền chiết khấu kiện','số tiền còn lại trong đơn','Ghi Chú'
  ],
  'don_hang_weber': [
    'Thời gian','Mã Đơn','Loại SP','Khách Hàng','Phân Loại KH',
    'Sản Phẩm','Đơn Giá','Số Lượng','Thành Tiền','số thùng','tổng thùng trong đơn','ghi chú đơn hàng'
  ],
  'don_hang_pima': [
    'Thời gian','Mã Đơn','Loại SP','Khách Hàng','Phân Loại KH',
    'Sản Phẩm','Đơn Giá','Số Lượng','Thành Tiền','tiền hỗ trợ vận chuyển','tổng tiền trong đơn','tổng tiền hỗ trợ vận chuyển','số tiền còn lại trong đơn','ghi chú'
  ]
};

function doGet(e) {
  const ss = SpreadsheetApp.openById(SHEET_ID);
  const params = e.parameter || {};
  
  // Handle getProductQuantity action
  if (params.action === 'getProductQuantity') {
    return getProductQuantity(params.productId, params.customerName || params.username);
  }
  
  // Original logic for fetching sheet data
  let sheetName = params.sheet;
  const category = params.category ? params.category.toString().toLowerCase() : '';

  if (!sheetName && category && CATEGORY_SHEETS[category]) {
    sheetName = CATEGORY_SHEETS[category];
  }

  // Default to first mapped sheet if none specified
  if (!sheetName) sheetName = Object.values(CATEGORY_SHEETS)[0];

  // Handle read_orders and read_customers as JSON
  if (params.action === 'read_orders' || params.action === 'read_customers') {
    const isOrders = params.action === 'read_orders';
    const email = params.email || '';
    const results = [];
    
    // For orders, check all mapped sheets
    const sheetsToRead = isOrders ? Object.values(CATEGORY_SHEETS) : ['khach_hang']; // Assuming a khach_hang sheet for customers if needed
    
    // If it's read_orders, we iterate over duraflex, weber, pima
    const targets = isOrders ? Object.values(CATEGORY_SHEETS) : [];
    
    targets.forEach(sName => {
      const sh = ss.getSheetByName(sName);
      if (!sh) return;
      const vals = sh.getDataRange().getValues();
      if (vals.length < 2) return;
      const hdrs = vals[0].map(h => normalizeHeader(h));
      const emailIdx = hdrs.indexOf('maidangnhap'); // or whatever key we use
      
      for (let i = 1; i < vals.length; i++) {
        let rowObj = {};
        hdrs.forEach((h, idx) => { rowObj[h] = vals[i][idx]; });
        
        // Filter by email if provided
        const rowEmail = rowObj['maidangnhap'] || rowObj['ten_dang_nhap'] || '';
        if (email && rowEmail.toLowerCase() !== email.toLowerCase()) continue;
        
        results.push(rowObj);
      }
    });

    return ContentService.createTextOutput(JSON.stringify({success: true, data: results})).setMimeType(ContentService.MimeType.JSON);
  }

  const sheet = ss.getSheetByName(sheetName);
  if (!sheet) return ContentService.createTextOutput("Error: Sheet not found: " + sheetName);

  const data = sheet.getDataRange().getValues();
  // Return CSV for lightweight fetch in frontend (original logic)
  let csv = "";
  for (let i = 0; i < data.length; i++) {
    // Escape values that contain commas or quotes
    const row = data[i].map(v => {
      if (v === null || v === undefined) return '';
      const s = v.toString();
      if (s.indexOf(',') >= 0 || s.indexOf('"') >= 0 || s.indexOf('\n') >= 0) {
        return '"' + s.replace(/"/g, '""') + '"';
      }
      return s;
    });
    csv += row.join(',') + "\n";
  }
  return ContentService.createTextOutput(csv).setMimeType(ContentService.MimeType.TEXT);
}

function normalizeHeader(h) {
  return String(h || '').trim()
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '')
    .replace(/\s+/g, '')
    .toLowerCase();
}

function getProductQuantity(productId, username) {
  try {
    const ss = SpreadsheetApp.openById(SHEET_ID);
    let totalQuantity = 0;
    
    // Search through all order sheets
    Object.values(CATEGORY_SHEETS).forEach(sheetName => {
      const sheet = ss.getSheetByName(sheetName);
      if (!sheet) return;
      const values = sheet.getDataRange().getValues();
      if (values.length < 2) return;
      const headers = values[0].map(normalizeHeader);
      
      const customerIdx = headers.indexOf('khachhang');
      const productIdx = headers.indexOf('sanpham');
      const productIdIdx = headers.indexOf('idsanpham');
      const qtyIdx = headers.indexOf('soluong');
      const statusIdx = headers.indexOf('trangthai');
      const emailIdx = headers.indexOf('maidangnhap');
      
      if (productIdx === -1 || qtyIdx === -1) return;
      
      for (let i = 1; i < values.length; i++) {
        const rowObj = {};
        headers.forEach((h, idx) => { rowObj[h] = values[i][idx]; });

        const rowEmail = rowObj['maidangnhap'] || rowObj['ten_dang_nhap'] || '';
        if (username && rowEmail.toLowerCase() !== username.toLowerCase()) continue;

        // Only count 'Chốt' status
        const status = String(rowObj['trangthai'] || '').toLowerCase();
        if (status !== 'chot' && status !== '') {
           // if status is empty, we assume it's an old 'Chốt' equivalent
        }

        const rowProdName = String(rowObj['sanpham'] || '').toLowerCase();
        const rowProdId = String(rowObj['idsanpham'] || '').toLowerCase();
        const searchId = String(productId || '').toLowerCase();

        if (rowProdId === searchId || rowProdName.includes(searchId)) {
          totalQuantity += parseFloat(rowObj['soluong']) || 0;
        }
      }
    });
    
    return ContentService.createTextOutput(JSON.stringify({
      success: true,
      quantity: totalQuantity
    })).setMimeType(ContentService.MimeType.JSON);
  } catch (err) {
    return ContentService.createTextOutput(JSON.stringify({
      success: false,
      message: err.toString()
    })).setMimeType(ContentService.MimeType.JSON);
  }
}

function getNextOrderId(category) {
  const ss = SpreadsheetApp.openById(SHEET_ID);
  let counterSheet = ss.getSheetByName(COUNTER_SHEET_NAME);
  
  // Tạo sheet counter nếu chưa có
  if (!counterSheet) {
    counterSheet = ss.insertSheet(COUNTER_SHEET_NAME);
    counterSheet.appendRow(["Category", "Counter"]);
    counterSheet.appendRow(["DURAFLEX", 0]);
    counterSheet.appendRow(["WEBER", 0]);
    counterSheet.appendRow(["PIMA", 0]);
  }
  
  // Lấy chữ cái đầu
  const prefix = category.charAt(0); // D, W, P
  
  // Tìm dòng của category
  const data = counterSheet.getDataRange().getValues();
  let rowIndex = -1;
  for (let i = 1; i < data.length; i++) {
    if (data[i][0] === category) {
      rowIndex = i + 1;
      break;
    }
  }
  
  if (rowIndex === -1) {
    counterSheet.appendRow([category, 0]);
    rowIndex = data.length + 1;
  }
  
  // Lấy giá trị counter hiện tại
  let counter = parseInt(counterSheet.getRange(rowIndex, 2).getValue()) || 0;
  counter++;
  
  // Cập nhật counter
  counterSheet.getRange(rowIndex, 2).setValue(counter);
  
  // Format ID: D01, D02, ... D99, D100, ...
  let idNumber = counter.toString().padStart(2, '0');
  if (counter > 99) {
    idNumber = counter.toString(); // 100, 101, 102, ...
  }
  
  return prefix + idNumber;
}

function doPost(e) {
  try {
    // Support both JSON body and form-encoded field `payload` (URLSearchParams from frontend)
    let data = {};
    try {
      if (e.parameter && e.parameter.payload) {
        data = JSON.parse(e.parameter.payload);
      } else if (e.postData && e.postData.contents) {
        data = JSON.parse(e.postData.contents);
      }
    } catch (parseErr) {
      data = {};
    }
    const action = data.action || 'add';
    const isEditMode = (action === 'update_order');
    const ss = SpreadsheetApp.openById(SHEET_ID);

    // Determine target sheet by category mapping
    const categoryName = (data.category || '').toString().toLowerCase();
    const targetSheetName = CATEGORY_SHEETS[categoryName] || CATEGORY_SHEETS['pima'];
    let sheet = ss.getSheetByName(targetSheetName);

    // If sheet missing, create with appropriate header row
    if (!sheet) {
      sheet = ss.insertSheet(targetSheetName);
      const headers = SHEET_HEADERS[targetSheetName] || ["Thời gian","Mã Đơn","Loại SP","Khách Hàng","Phân Loại KH","Sản Phẩm","Đơn Giá","Số Lượng","Thành Tiền","Ghi Chú"];
      sheet.appendRow(headers);
    }

    if (action === 'delete_order') {
      const orderId = (data.orderId || '').toString();
      if (!orderId) throw new Error("Missing OrderId");
      const values = sheet.getDataRange().getValues();
      let count = 0;
      for (let i = values.length - 1; i >= 1; i--) {
        if (values[i][1].toString() === orderId) {
          sheet.deleteRow(i + 1);
          count++;
        }
      }
      return ContentService.createTextOutput(JSON.stringify({result: 'success', deletedRows: count})).setMimeType(ContentService.MimeType.JSON);
    }

    const timestamp = isEditMode ? (data.time ? new Date(data.time) : new Date()) : new Date();
    const orderId = isEditMode ? data.orderId : getNextOrderId(data.category);
    const targetKey = sheet.getName();

    if (isEditMode) {
      const values = sheet.getDataRange().getValues();
      let found = false;
      for (let i = values.length - 1; i >= 1; i--) {
        if (values[i][1].toString() === orderId.toString()) {
          sheet.deleteRow(i + 1);
          found = true;
        }
      }
      if (!found) {
        return ContentService.createTextOutput(JSON.stringify({result: 'error', message: 'Order not found for update'})).setMimeType(ContentService.MimeType.JSON);
      }
    }

    // Summary fields sent from frontend
    const discountTotal = data.discount_total || 0;
    const totalAfterDiscount = data.total_after_discount || data.total || 0;
    const totalBoxes = data.total_boxes || 0;
    const totalSupport = data.total_support || 0;
    const totalAfterSupport = data.total_after_support || data.total || 0;
    const grossTotal = parseFloat(data.total) + parseFloat(totalSupport); // sum of Chanh prices

    data.items.forEach((item, index) => {
      let row = [];
      if (targetKey === CATEGORY_SHEETS['duraflex']) {
        const packages = item.packages || 0;
        const discountVal = item.discount_amount || discountTotal || 0;
        const finalTotal = totalAfterDiscount;
        row = [timestamp, orderId, data.category, (data.customer && data.customer.name) || '', (data.customer && data.customer.phan_loai) || '', item.name || '', item.unit_price || '', item.quantity || '', item.subtotal || '', packages, discountVal, finalTotal, data.notes || ''];
      } else if (targetKey === CATEGORY_SHEETS['weber']) {
        const boxes = item.boxes || 0;
        const totalBoxesInOrder = totalBoxes || 0;
        row = [timestamp, orderId, data.category, (data.customer && data.customer.name) || '', (data.customer && data.customer.phan_loai) || '', item.name || '', item.unit_price || '', item.quantity || '', item.subtotal || '', boxes, totalBoxesInOrder, data.notes || ''];
      } else if (targetKey === CATEGORY_SHEETS['pima']) {
        const support = item.surplus || 0;
        row = [timestamp, orderId, data.category, (data.customer && data.customer.name) || '', (data.customer && data.customer.phan_loai) || '', item.name || '', item.unit_price || '', item.quantity || '', item.subtotal || '', support, grossTotal, totalSupport, totalAfterSupport, data.notes || ''];
      } else {
        row = [timestamp, orderId, data.category, (data.customer && data.customer.name) || '', (data.customer && data.customer.phan_loai) || '', item.name || '', item.unit_price || '', item.quantity || '', item.subtotal || '', data.notes || ''];
      }
      sheet.appendRow(row);
    });

    return ContentService.createTextOutput(JSON.stringify({result: 'success', orderId: orderId})).setMimeType(ContentService.MimeType.JSON);
  } catch (error) {
    return ContentService.createTextOutput(JSON.stringify({result: 'error', message: error.toString()})).setMimeType(ContentService.MimeType.JSON);
  }
}
