/**
 * GAS SCRIPT QUẢN LÝ ĐƠN HÀNG VÀ KHÁCH HÀNG & SẢN PHẨM (All-in-One)
 * Thực hiện: CRUD Khách hàng, CRUD Đơn hàng, CRUD Sản phẩm
 */

const SPREADSHEET_ID = '1x_DgdgVJVjkzZt8_e7Zg0gqDnG7oHmV0H7DgebVzD3E';
const SHEET_KHACH = 'data_khach';
const SHEET_DON = 'don_hang';
const SHEET_SAN_PHAM = 'data_san_pham_kh';
const SHEET_TON_KHO = 'ton_kho';

function doGet(e) {
  try {
    const action = e.parameter.action;
    const email = e.parameter.email || e.parameter.username;
    const productId = e.parameter.productId;
    
    if (action === 'read_customers') return readData(SHEET_KHACH, email);
    if (action === 'read_orders') return readData(SHEET_DON, email);
    if (action === 'read') return readData(SHEET_SAN_PHAM, email); // Action for products
    if (action === 'readInventory') return readData(SHEET_TON_KHO, email);
    if (action === 'getProductQuantity') return getProductQuantity(productId, email);
    
    return jsonResponse({success: false, message: 'Invalid GET action: ' + action});
  } catch (err) {
    return jsonResponse({success: false, message: err.toString()});
  }
}

function doPost(e) {
  let payload;
  try { 
    payload = JSON.parse(e.postData.contents); 
  } catch (err) { 
    try {
      if (e.parameter.payload) {
        payload = JSON.parse(e.parameter.payload);
      } else {
        return jsonResponse({success: false, message: 'Invalid JSON or missing payload'}); 
      }
    } catch (e2) {
      return jsonResponse({success: false, message: 'Invalid payload: ' + e2.toString()});
    }
  }
  
  try {
    const action = payload.action;
    
    // Customers
    if (action === 'upsert_customer') return upsertCustomer(payload.data);
    if (action === 'delete_customer') return deleteItem(SHEET_KHACH, 'id khách hàng', payload.id);
    
    // Orders
    if (action === 'create_order') return createOrder(payload.data);
    if (action === 'update_order') return updateOrder(payload.id, payload.data);
    if (action === 'delete_order') return deleteItem(SHEET_DON, 'id đơn hàng', payload.id);
    
    // Products
    if (action === 'create' || action === 'update') return upsertProduct(payload.data, payload.idValue);
    if (action === 'delete') return deleteItem(SHEET_SAN_PHAM, 'id_san_pham', payload.idValue);

    // Inventory
    if (action === 'upsert_inventory') return upsertInventory(payload.data);

    return jsonResponse({success: false, message: 'Invalid POST action: ' + action});
  } catch (err) {
    return jsonResponse({success: false, message: err.toString()});
  }
}

// Hàm chuẩn hóa header: không dấu, không khoảng trắng, không gạch dưới, không 'đ', viết thường
function normalizeHeader(h) {
  if (!h) return '';
  return String(h).trim()
    .replace(/đ/g, 'd')                  // Xử lý chữ đ
    .replace(/Đ/g, 'd')                  // Xử lý chữ Đ
    .normalize('NFD')                     // Tách dấu
    .replace(/[\u0300-\u036f]/g, '')     // Loại bỏ dấu
    .replace(/[\s_]+/g, '')               // Loại bỏ khoảng trắng và gạch dưới
    .toLowerCase();                       // Chuyển sang chữ thường
}

// Function to get index of a column by normalized name
function getColIdx(headers, searchName) {
  return headers.indexOf(normalizeHeader(searchName));
}

function readData(sheetName, email) {
  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    let sheet = ss.getSheetByName(sheetName);
    if (!sheet) {
      sheet = ss.insertSheet(sheetName);
      if (sheetName === SHEET_KHACH) {
        // Updated headers based on user image: Removed 'phân loại khách hàng'
        sheet.appendRow(['tên khách hàng', 'id khách hàng', 'phone', 'ghi chú', 'mail đăng nhập', 'trạng thái xóa', 'ngày tạo']);
      } else if (sheetName === SHEET_DON) {
        sheet.appendRow(['phân loại khách hàng', 'tên khách hàng', 'id khách hàng', 'id đơn hàng', 'tên ngành hàng', 'tên sản phẩm', 'id sản phẩm', 'giá sản phẩm', 'số lượng', 'thành tiền', 'tổng tiền hàng', 'dịch vụ thêm trong đơn', 'tổng tiền trong đơn', 'ghi chú', 'mail đăng nhập', 'trạng thái xóa', 'trạng thái đơn hàng', 'ngày tạo']);
      } else if (sheetName === SHEET_SAN_PHAM) {
        sheet.appendRow(['id_san_pham', 'image_san_pham', 'ten_nghanh_hang', 'ten_san_pham', 'gia_san_pham', 'ten_dang_nhap', 'trang_thai_xoa_sp']);
      } else if (sheetName === SHEET_TON_KHO) {
        sheet.appendRow(['date', 'tên sản phẩm', 'id sản phẩm', 'số lượng', 'trạng thái', 'còn lại', 'ten_dang_nhap']);
      }
    }
    
    const values = sheet.getDataRange().getValues();
    if (values.length < 1) return jsonResponse({success: true, data: []});
    
    const rawHeaders = values[0];
    const headers = rawHeaders.map(normalizeHeader);
    
    // Determine email and delete columns based on sheet type
    let emailIdx = getColIdx(headers, 'maildangnhap');
    if (emailIdx === -1) emailIdx = getColIdx(headers, 'tendangnhap');
    if (emailIdx === -1) emailIdx = getColIdx(headers, 'nguoitao');

    let deleteIdx = getColIdx(headers, 'trangthaixoa');
    if (deleteIdx === -1) deleteIdx = headers.indexOf('trang_thai_xoa_sp');
    if (deleteIdx === -1) deleteIdx = headers.indexOf('trangthaixoasp');
    
    const data = [];
    for (let i = 1; i < values.length; i++) {
        if (!values[i].join('').trim()) continue;
        let obj = {};
        rawHeaders.forEach((h, index) => { 
          const normH = normalizeHeader(h);
          obj[normH] = values[i][index]; 
          // Backup key for compatibility
          obj[h.toLowerCase().replace(/\s+/g, '')] = values[i][index];
          // Special case for product ID to match frontend expectation sometimes
          if (normH === 'idsanpham') obj['id_san_pham'] = values[i][index];
        });
        
        const itemEmail = emailIdx !== -1 ? String(values[i][emailIdx]).trim() : '';
        const isDeleted = deleteIdx !== -1 ? values[i][deleteIdx] === 'DELETED' : false;
        
        if (!isDeleted) {
          if (!email || emailIdx === -1 || itemEmail.toLowerCase() === email.toLowerCase()) {
            data.push(obj);
          }
        }
    }
    return jsonResponse({success: true, data: data});
  } catch (err) { return jsonResponse({success: false, message: err.toString()}); }
}

function upsertCustomer(data) {
  // Add creation time if missing (usually for new records)
  if (!data['ngày tạo'] && !data['ngaytao']) {
    data['ngày tạo'] = Utilities.formatDate(new Date(), Session.getScriptTimeZone(), "dd/MM/yyyy HH:mm:ss");
  }
  return genericUpsert(SHEET_KHACH, data, 'id khách hàng', 'KH', 'idkhachhang');
}

function upsertProduct(data, idValue) {
  // Frontend might send data keys that need mapping to sheet headers
  // Map frontend keys to sheet headers if necessary, or ensure consistency
  // Frontend sends: ten_san_pham, gia_san_pham, etc.
  // Sheet headers: ten_san_pham, gia_san_pham... (Snake case in sheet based on image)
  // Let's assume keys match or are normalized.
  
  if (idValue) data['id_san_pham'] = idValue;
  return genericUpsert(SHEET_SAN_PHAM, data, 'id_san_pham', 'S', 'idsanpham');
}

// Helper to calculate current stock for a product
function getStock(productId) {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName(SHEET_TON_KHO);
  if (!sheet) return 0;
  const values = sheet.getDataRange().getValues();
  if (values.length < 2) return 0;
  
  const headers = values[0].map(normalizeHeader);
  const idIdx = getColIdx(headers, 'idsanpham');
  const nhapIdx = getColIdx(headers, 'nhap');
  const xuatIdx = getColIdx(headers, 'xuat');
  
  if (idIdx === -1 || (nhapIdx === -1 && xuatIdx === -1)) return 0;
  
  let total = 0;
  for (let i = 1; i < values.length; i++) {
    const row = values[i];
    if (String(row[idIdx]) === String(productId)) {
      const n = (nhapIdx !== -1) ? (parseFloat(row[nhapIdx]) || 0) : 0;
      const x = (xuatIdx !== -1) ? (parseFloat(row[xuatIdx]) || 0) : 0;
      total += (n - x);
    }
  }
  return total;
}

function upsertInventory(data) {
  try {
     const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
     let sheet = ss.getSheetByName(SHEET_TON_KHO);
     const headerRow = ['date', 'tên sản phẩm', 'id sản phẩm', 'nhập', 'xuất', 'còn lại', 'ghi chú', 'ten_dang_nhap'];
     
     if (!sheet) {
        sheet = ss.insertSheet(SHEET_TON_KHO);
        sheet.appendRow(headerRow);
     }
     
     const rawHeaders = sheet.getRange(1,1,1,sheet.getLastColumn()).getValues()[0];
     const headers = rawHeaders.map(normalizeHeader);

     // Calculate current stock
     const prodId = data.id_san_pham || data['id sản phẩm'] || '';
     const currentStock = getStock(prodId);
     const nhapVal = parseFloat(data.so_luong_nhap || data['nhập'] || 0) || 0;
     const xuatVal = parseFloat(data.so_luong_xuat || data['xuất'] || 0) || 0;
     const newRemaining = currentStock + nhapVal - xuatVal;

     const rowData = rawHeaders.map(h => {
        const norm = normalizeHeader(h);
        if (norm === 'date') return data.date || Utilities.formatDate(new Date(), Session.getScriptTimeZone(), "yyyy-MM-dd");
        if (norm === 'tensanpham') return data.ten_san_pham || data['tên sản phẩm'] || '';
        if (norm === 'idsanpham') return prodId;
        if (norm === 'nhap') return nhapVal || '';
        if (norm === 'xuat') return xuatVal || '';
        if (norm === 'conlai') return newRemaining;
        if (norm === 'ghichu') return data.ghi_chu || data['ghi chú'] || '';
        if (norm === 'tendangnhap') return data.ten_dang_nhap || userData.email || '';
        return '';
     });

     sheet.appendRow(rowData);
     return jsonResponse({success: true, remaining: newRemaining});
  } catch (e) { return jsonResponse({success: false, message: e.toString()}); }
}

function genericUpsert(sheetName, data, idColName, prefix, altIdColName) {
  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    let sheet = ss.getSheetByName(sheetName);
    if (!sheet) {
      sheet = ss.insertSheet(sheetName);
      // Header creation is handled in readData if missing, but we can init here too
       if (sheetName === SHEET_SAN_PHAM) {
        sheet.appendRow(['id_san_pham', 'image_san_pham', 'ten_nghanh_hang', 'ten_san_pham', 'gia_san_pham', 'ten_dang_nhap', 'trang_thai_xoa_sp']);
      }
    }
    
    let values = sheet.getDataRange().getValues();
     if (values.length === 0 || (values.length === 1 && values[0].every(c => c === ""))) {
       let headerRow = [];
       if (sheetName === SHEET_KHACH) headerRow = ['tên khách hàng', 'id khách hàng', 'phone', 'ghi chú', 'mail đăng nhập', 'trạng thái xóa', 'ngày tạo'];
       else if (sheetName === SHEET_SAN_PHAM) headerRow = ['id_san_pham', 'image_san_pham', 'ten_nghanh_hang', 'ten_san_pham', 'gia_san_pham', 'ten_dang_nhap', 'trang_thai_xoa_sp'];
       
       if (headerRow.length > 0) {
         sheet.appendRow(headerRow);
         values = sheet.getDataRange().getValues();
       }
    }

    const rawHeaders = values[0];
    const headers = rawHeaders.map(normalizeHeader);
    
    const normIdCol = normalizeHeader(idColName);
    const normAltIdCol = altIdColName ? normalizeHeader(altIdColName) : '';
    
    let idIdx = headers.indexOf(normIdCol);
    if (idIdx === -1 && normAltIdCol) idIdx = headers.indexOf(normAltIdCol);
    
    // Auto ID
    let currentId = data[idColName] || (altIdColName ? data[altIdColName] : '');
    
    if (!currentId && idIdx !== -1) {
      let nextNum = 1;
      if (values.length > 1) {
        const ids = values.slice(1).map(r => r[idIdx]).filter(id => id && String(id).startsWith(prefix));
        const nums = ids.map(id => parseInt(id.replace(prefix, '')) || 0);
        if (nums.length > 0) nextNum = Math.max(...nums) + 1;
      }
      currentId = prefix + String(nextNum).padStart(3, '0');
      data[idColName] = currentId;
    }

    let foundRow = -1;
    if (idIdx !== -1 && currentId) {
      for (let i = 1; i < values.length; i++) {
        if (String(values[i][idIdx]) === String(currentId)) {
          foundRow = i + 1;
          break;
        }
      }
    }

    const rowData = rawHeaders.map(h => {
      const normH = normalizeHeader(h);
      // Try exact match, then normalized match
      let val = data[h];
      if (val === undefined) val = data[normH];
      
      // Fallback for snake_case vs no space
      if (val === undefined) {
         // e.g. h='ten_san_pham', data has 'ten_san_pham' -> matched by exact
         // e.g. h='ten san pham', data has 'ten_san_pham' -> normH='tensanpham', data key 'ten_san_pham' -> mismatch if not careful
         // Try to find a key in data that normalizes to normH
         const matchingKey = Object.keys(data).find(k => normalizeHeader(k) === normH);
         if (matchingKey) val = data[matchingKey];
      }
      return val !== undefined ? val : '';
    });

    if (foundRow !== -1) {
      sheet.getRange(foundRow, 1, 1, rowData.length).setValues([rowData]);
    } else {
      sheet.appendRow(rowData);
    }
    
    return jsonResponse({success: true, id: currentId});

  } catch (err) { return jsonResponse({success: false, message: err.toString()}); }
}

function createOrder(orderDataArray) {
  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    let sheet = ss.getSheetByName(SHEET_DON);
    if (!sheet) return jsonResponse({success: false, message: 'Sheet ' + SHEET_DON + ' not found'});
    
    const rawHeaders = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    const headers = rawHeaders.map(normalizeHeader);

    const values = sheet.getDataRange().getValues();
    let idDonIdx = getColIdx(headers, 'iddonhang');
    if (idDonIdx === -1) idDonIdx = getColIdx(headers, 'madonhang');
    if (idDonIdx === -1) idDonIdx = getColIdx(headers, 'madon');

    let nextNum = 1;
    if (values.length > 1) {
      const ids = values.slice(1).map(r => r[idDonIdx]).filter(id => id && String(id).startsWith('DH'));
      const nums = ids.map(id => parseInt(id.replace('DH', '')) || 0);
      if (nums.length > 0) nextNum = Math.max(...nums) + 1;
    }
    const orderId = 'DH' + String(nextNum).padStart(3, '0');

    // 1. Save to Order Sheet
    orderDataArray.forEach(item => {
      item['id đơn hàng'] = orderId;
      item['iddonhang'] = orderId;
      
      const rowData = rawHeaders.map(h => {
        const normH = normalizeHeader(h);
        return item[h] !== undefined ? item[h] : (item[normH] !== undefined ? item[normH] : '');
      });
      sheet.appendRow(rowData);
    });
    
    // 2. Log to Inventory Sheet (Xuất kho)
    let sheetTon = ss.getSheetByName(SHEET_TON_KHO);
    const headerRowTon = ['date', 'tên sản phẩm', 'id sản phẩm', 'nhập', 'xuất', 'còn lại', 'ghi chú', 'ten_dang_nhap'];
    if (!sheetTon) {
        sheetTon = ss.insertSheet(SHEET_TON_KHO);
        sheetTon.appendRow(headerRowTon);
    }
    
    const rawHeadersTon = sheetTon.getRange(1, 1, 1, sheetTon.getLastColumn()).getValues()[0];
    const headersTon = rawHeadersTon.map(normalizeHeader);
    
    const todayStr = Utilities.formatDate(new Date(), Session.getScriptTimeZone(), "yyyy-MM-dd");
    orderDataArray.forEach(item => {
        const prodName = item['tên sản phẩm'] || item['tênsảnphẩm'] || item['tensanpham'] || '';
        const prodId = item['id sản phẩm'] || item['idsảnphẩm'] || item['idsanpham'] || '';
        const qty = parseFloat(item['số lượng'] || item['sốlượng'] || item['soluong']) || 0;
        const email = item['mail đăng nhập'] || item['maildangnhap'] || item['nguoitao'] || '';
        
        if (prodName && qty > 0) {
            const currentStock = getStock(prodId);
            const newStock = currentStock - qty;
            
            const rowDataTon = rawHeadersTon.map(h => {
                const norm = normalizeHeader(h);
                if (norm === 'date') return todayStr;
                if (norm === 'tensanpham') return prodName;
                if (norm === 'idsanpham') return prodId;
                if (norm === 'nhap') return '';
                if (norm === 'xuat') return qty;
                if (norm === 'conlai') return newStock;
                if (norm === 'tendangnhap') return email;
                if (norm === 'ghichu') return 'Xuất từ đơn hàng ' + orderId;
                return '';
            });
            sheetTon.appendRow(rowDataTon);
        }
    });

    return jsonResponse({success: true, orderId: orderId});
  } catch (err) {
    return jsonResponse({success: false, message: err.toString()});
  }
}

function updateOrder(orderId, orderDataArray) {
  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const sheet = ss.getSheetByName(SHEET_DON);
    const lastValues = sheet.getDataRange().getValues();
    const rawHeaders = lastValues[0];
    const headers = rawHeaders.map(normalizeHeader);
    let idDonIdx = getColIdx(headers, 'iddonhang');
    if (idDonIdx === -1) idDonIdx = getColIdx(headers, 'madonhang');
    if (idDonIdx === -1) idDonIdx = getColIdx(headers, 'madon');

    if (idDonIdx === -1) return jsonResponse({success: false, message: 'ID Đơn hàng column not found'});

    // Xóa các dòng cũ của đơn này
    for (let i = lastValues.length - 1; i >= 1; i--) {
      if (String(lastValues[i][idDonIdx]) === String(orderId)) {
        sheet.deleteRow(i + 1);
      }
    }

    // Thêm các dòng mới
    orderDataArray.forEach(item => {
      item['id đơn hàng'] = orderId;
      item['iddonhang'] = orderId;
      const rowData = rawHeaders.map(h => {
        const normH = normalizeHeader(h);
        return item[h] !== undefined ? item[h] : (item[normH] !== undefined ? item[normH] : '');
      });
      sheet.appendRow(rowData);
    });

    return jsonResponse({success: true});
  } catch (err) {
    return jsonResponse({success: false, message: err.toString()});
  }
}

function deleteItem(sheetName, idColName, idValue) {
  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const sheet = ss.getSheetByName(sheetName);
    const values = sheet.getDataRange().getValues();
    const headers = values[0].map(normalizeHeader);
    
    // Normalize idColName to match header
    const normIdColName = normalizeHeader(idColName);
    let idIdx = headers.indexOf(normIdColName);
    
    // Try finding alternative IDs if standard one not found
    if (idIdx === -1) {
       if (normIdColName === 'idsanpham') idIdx = headers.indexOf('idsanpham'); // e.g. id_san_pham vs idsanpham
    }

    let deleteIdx = headers.indexOf('trangthaixoa');
    if (deleteIdx === -1) deleteIdx = headers.indexOf('trangthaixoasp');
    
    if (idIdx === -1 || deleteIdx === -1) throw new Error('Cột ID (' + idColName + ') hoặc Trạng thái xóa không tồn tại');

    let found = false;
    for (let i = 1; i < values.length; i++) {
      if (String(values[i][idIdx]) === String(idValue)) {
        sheet.getRange(i + 1, deleteIdx + 1).setValue('DELETED');
        found = true;
      }
    }
    return jsonResponse({success: true, found: found});
  } catch (err) { return jsonResponse({success: false, message: err.toString()}); }
}

function getProductQuantity(productId, username) {
  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const sheet = ss.getSheetByName(SHEET_DON);
    if (!sheet) return jsonResponse({success: true, quantity: 0});
    
    const values = sheet.getDataRange().getValues();
    if (values.length < 2) return jsonResponse({success: true, quantity: 0});
    
    const headers = values[0].map(normalizeHeader);
    const productIdx = headers.indexOf('tensanpham');
    const productIdIdx = headers.indexOf('idsanpham');
    const qtyIdx = headers.indexOf('soluong');
    const statusIdx = headers.indexOf('trangthaidonhang');
    const emailIdx = headers.indexOf('maildangnhap'); // Or nguoitao
    
    let deleteIdx = headers.indexOf('trangthaixoa');
    
    if (productIdx === -1 || qtyIdx === -1) return jsonResponse({success: true, quantity: 0});
    
    let totalQuantity = 0;
    for (let i = 1; i < values.length; i++) {
      const row = values[i];
      const isDeleted = deleteIdx !== -1 ? row[deleteIdx] === 'DELETED' : false;
      const status = statusIdx !== -1 ? String(row[statusIdx]).toLowerCase() : '';
      const email = emailIdx !== -1 ? String(row[emailIdx]).toLowerCase() : '';
      
      if (isDeleted) continue;
      // Chỉ tính các đơn đã Chốt (hoặc mặc định nếu không có cột trạng thái)
      if (statusIdx !== -1 && status.indexOf('chot') === -1 && status !== '') continue;
      // Lọc theo user nếu có
      if (username && email && email !== username.toLowerCase()) continue;
      
      const rowProdName = String(row[productIdx]).toLowerCase();
      const rowProdId = productIdIdx !== -1 ? String(row[productIdIdx]).toLowerCase() : '';
      const searchId = String(productId).toLowerCase();
      
      if (rowProdId === searchId || rowProdName === searchId) {
        totalQuantity += parseFloat(row[qtyIdx]) || 0;
      }
    }
    
    return jsonResponse({success: true, quantity: totalQuantity});
  } catch (err) {
    return jsonResponse({success: false, message: err.toString()});
  }
}

function jsonResponse(obj) {
  return ContentService.createTextOutput(JSON.stringify(obj)).setMimeType(ContentService.MimeType.JSON);
}
